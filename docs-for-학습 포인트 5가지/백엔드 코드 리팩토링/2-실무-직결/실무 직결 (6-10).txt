================================================================
실무 백엔드(Spring Boot + MyBatis) 이해를 위한 핵심 30가지
================================================================

================================================================
실무 직결 (6~10)
================================================================

6. @Scheduled 스케줄러
----------------------------------------------------------------
  - cron 표현식: "초 분 시 일 월 요일"
    예) "0 0/5 * * * *" → 5분마다 실행
  - 현업 활용: 실패한 외부 API 동기화 자동 재시도
  - 주의: 단일 스레드 기본 → 오래 걸리는 작업은 @Async 병행

  핵심 질문:
    "스케줄러가 실행 중에 다음 스케줄이 도래하면 어떻게 되는가?"


7. 트랜잭션 전파 (Propagation)
----------------------------------------------------------------
  - REQUIRED (기본값): 기존 트랜잭션 있으면 참여, 없으면 새로 생성
    → 실패 시 전체 롤백
  - REQUIRES_NEW: 무조건 새 트랜잭션 생성, 기존 트랜잭션과 독립
    → 외부 API 호출 결과를 별도 저장할 때 사용
  - 현업 활용: SAP API 호출 성공/실패 이력을 메인 트랜잭션과 분리 저장

  핵심 질문:
    "REQUIRES_NEW로 분리한 트랜잭션은 메인 트랜잭션 롤백에 영향받는가?"


8. 커넥션 풀 (HikariCP)
----------------------------------------------------------------
  - DB 연결을 미리 생성해두고 재사용 (연결 비용 절감)
  - maximum-pool-size: 최대 동시 DB 연결 수
  - connection-timeout: 커넥션 대기 최대 시간
  - 문제 상황:
      @Transactional 메서드 안에서 외부 API 5분 대기
      → 그 동안 커넥션 1개 점유
      → 동시 요청 많으면 커넥션 고갈 → 전체 서비스 장애

  핵심 질문:
    "커넥션 풀 고갈은 어떤 상황에서 발생하는가?"


9. 예외 처리 전략
----------------------------------------------------------------
  - @ControllerAdvice + @ExceptionHandler: 전역 예외 처리
  - Unchecked Exception (RuntimeException): @Transactional 기본 롤백 대상
  - Checked Exception (Exception): 기본적으로 롤백 안 됨
    → rollbackFor = Exception.class 명시 필요
  - 현업 주의: catch로 예외를 삼키면 트랜잭션이 롤백 안 됨

  핵심 질문:
    "Checked Exception 발생 시 트랜잭션이 롤백되지 않는 이유는?"


10. @Async + 외부 API 호출
----------------------------------------------------------------
  - @Async: 별도 스레드에서 비동기 실행
    → 호출한 메서드의 트랜잭션과 완전히 분리됨
  - 외부 API(SAP 등)를 트랜잭션 밖으로 빼는 패턴:
      1) DB 저장 (트랜잭션 커밋)
      2) @Async로 외부 API 호출
      3) 실패 시 sync_status = 'FAILED' 기록 → 재시도 스케줄러
  - @EnableAsync: 메인 클래스 또는 설정 클래스에 선언 필요

  핵심 질문:
    "@Async 메서드가 같은 클래스 안에 있으면 왜 동작 안 하는가?"
    (→ @Transactional과 같은 이유: 프록시 Self-Invocation 문제)

================================================================
