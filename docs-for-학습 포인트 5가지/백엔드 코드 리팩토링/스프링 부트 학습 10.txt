================================================================
실무 백엔드(Spring Boot + MyBatis) 이해를 위한 핵심 10가지
================================================================

================================================================
기본 구조 (1~5)
================================================================

1. @Transactional 동작 원리
----------------------------------------------------------------
  - Spring은 @Transactional을 프록시 객체로 감싸서 처리
  - 같은 클래스 내에서 자기 메서드를 호출하면 프록시를 거치지 않음
    → 트랜잭션이 적용 안 됨 (Self-Invocation 문제)
  - 해결책: Self-Proxy 패턴 (자기 자신을 @Autowired로 주입)
  - 현업 코드에서 직접 등장한 패턴 (CrdtCardAck)

  핵심 질문:
    "왜 같은 클래스 안에서 호출하면 @Transactional이 안 먹히나?"


2. MyBatis 동작 방식
----------------------------------------------------------------
  - Mapper 인터페이스 → XML(SQL) → DB 순으로 실행
  - SqlSession이 DB 연결을 담당
  - #{} : PreparedStatement (SQL 인젝션 방지, 값 바인딩)
  - ${} : 문자열 직접 치환 (테이블명, 컬럼명 동적 처리 시 사용, 위험)
  - resultMap : DB 컬럼명과 Java 필드명 매핑 (snake_case → camelCase)
  - map-underscore-to-camel-case: true 설정으로 자동 변환 가능

  핵심 질문:
    "#{} 와 ${} 의 차이와 각각 언제 쓰는가?"


3. Spring Bean 생명주기 + DI
----------------------------------------------------------------
  - @Component, @Service, @Repository, @Controller
    → 전부 Bean 등록이지만 계층별 의미 구분
  - 생성자 주입 (권장): 불변성 보장, 테스트 용이
  - 필드 주입 (@Autowired): 간편하지만 테스트 어려움
  - @RequiredArgsConstructor (Lombok): final 필드 생성자 자동 생성

  핵심 질문:
    "왜 생성자 주입을 권장하는가?"


4. Spring MVC 요청 흐름
----------------------------------------------------------------
  요청 → DispatcherServlet → HandlerMapping → Controller
       → Service → Mapper → DB
       → 응답 역순

  - @RequestBody  : JSON → Java 객체 (역직렬화)
  - @ResponseBody : Java 객체 → JSON (직렬화)
  - @RestController = @Controller + @ResponseBody
  - DTO로 요청/응답 데이터 분리 (Entity 직접 노출 금지)

  핵심 질문:
    "DispatcherServlet이 하는 역할은?"


5. Spring Security + JWT
----------------------------------------------------------------
  - 필터 체인 구조: 요청이 Controller 도달 전에 Security 필터 통과
  - JWT 흐름:
      로그인 → 토큰 발급 → 요청마다 헤더에 토큰 첨부
      → JwtFilter에서 토큰 검증 → SecurityContext에 인증 정보 세팅
  - 권한 처리: @PreAuthorize, SecurityContext의 Authentication 객체

  핵심 질문:
    "JWT 토큰 검증은 어느 시점에, 어디서 이루어지는가?"


================================================================
실무 직결 (6~10)
================================================================

6. @Scheduled 스케줄러
----------------------------------------------------------------
  - cron 표현식: "초 분 시 일 월 요일"
    예) "0 0/5 * * * *" → 5분마다 실행
  - 현업 활용: 실패한 외부 API 동기화 자동 재시도
  - 주의: 단일 스레드 기본 → 오래 걸리는 작업은 @Async 병행

  핵심 질문:
    "스케줄러가 실행 중에 다음 스케줄이 도래하면 어떻게 되는가?"


7. 트랜잭션 전파 (Propagation)
----------------------------------------------------------------
  - REQUIRED (기본값): 기존 트랜잭션 있으면 참여, 없으면 새로 생성
    → 실패 시 전체 롤백
  - REQUIRES_NEW: 무조건 새 트랜잭션 생성, 기존 트랜잭션과 독립
    → 외부 API 호출 결과를 별도 저장할 때 사용
  - 현업 활용: SAP API 호출 성공/실패 이력을 메인 트랜잭션과 분리 저장

  핵심 질문:
    "REQUIRES_NEW로 분리한 트랜잭션은 메인 트랜잭션 롤백에 영향받는가?"


8. 커넥션 풀 (HikariCP)
----------------------------------------------------------------
  - DB 연결을 미리 생성해두고 재사용 (연결 비용 절감)
  - maximum-pool-size: 최대 동시 DB 연결 수
  - connection-timeout: 커넥션 대기 최대 시간
  - 문제 상황:
      @Transactional 메서드 안에서 외부 API 5분 대기
      → 그 동안 커넥션 1개 점유
      → 동시 요청 많으면 커넥션 고갈 → 전체 서비스 장애

  핵심 질문:
    "커넥션 풀 고갈은 어떤 상황에서 발생하는가?"


9. 예외 처리 전략
----------------------------------------------------------------
  - @ControllerAdvice + @ExceptionHandler: 전역 예외 처리
  - Unchecked Exception (RuntimeException): @Transactional 기본 롤백 대상
  - Checked Exception (Exception): 기본적으로 롤백 안 됨
    → rollbackFor = Exception.class 명시 필요
  - 현업 주의: catch로 예외를 삼키면 트랜잭션이 롤백 안 됨

  핵심 질문:
    "Checked Exception 발생 시 트랜잭션이 롤백되지 않는 이유는?"


10. @Async + 외부 API 호출
----------------------------------------------------------------
  - @Async: 별도 스레드에서 비동기 실행
    → 호출한 메서드의 트랜잭션과 완전히 분리됨
  - 외부 API(SAP 등)를 트랜잭션 밖으로 빼는 패턴:
      1) DB 저장 (트랜잭션 커밋)
      2) @Async로 외부 API 호출
      3) 실패 시 sync_status = 'FAILED' 기록 → 재시도 스케줄러
  - @EnableAsync: 메인 클래스 또는 설정 클래스에 선언 필요

  핵심 질문:
    "@Async 메서드가 같은 클래스 안에 있으면 왜 동작 안 하는가?"
    (→ @Transactional과 같은 이유: 프록시 Self-Invocation 문제)

================================================================
