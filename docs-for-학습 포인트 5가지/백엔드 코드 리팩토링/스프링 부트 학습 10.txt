================================================================
실무 백엔드(Spring Boot + MyBatis) 이해를 위한 핵심 30가지
================================================================

================================================================
기본 구조 (1~5)
================================================================

1. @Transactional 동작 원리
----------------------------------------------------------------
  - Spring은 @Transactional을 프록시 객체로 감싸서 처리
  - 같은 클래스 내에서 자기 메서드를 호출하면 프록시를 거치지 않음
    → 트랜잭션이 적용 안 됨 (Self-Invocation 문제)
  - 해결책: Self-Proxy 패턴 (자기 자신을 @Autowired로 주입)
  - 현업 코드에서 직접 등장한 패턴 (CrdtCardAck)

  핵심 질문:
    "왜 같은 클래스 안에서 호출하면 @Transactional이 안 먹히나?"


2. MyBatis 동작 방식
----------------------------------------------------------------
  - Mapper 인터페이스 → XML(SQL) → DB 순으로 실행
  - SqlSession이 DB 연결을 담당
  - #{} : PreparedStatement (SQL 인젝션 방지, 값 바인딩)
  - ${} : 문자열 직접 치환 (테이블명, 컬럼명 동적 처리 시 사용, 위험)
  - resultMap : DB 컬럼명과 Java 필드명 매핑 (snake_case → camelCase)
  - map-underscore-to-camel-case: true 설정으로 자동 변환 가능

  핵심 질문:
    "#{} 와 ${} 의 차이와 각각 언제 쓰는가?"


3. Spring Bean 생명주기 + DI
----------------------------------------------------------------
  - @Component, @Service, @Repository, @Controller
    → 전부 Bean 등록이지만 계층별 의미 구분
  - 생성자 주입 (권장): 불변성 보장, 테스트 용이
  - 필드 주입 (@Autowired): 간편하지만 테스트 어려움
  - @RequiredArgsConstructor (Lombok): final 필드 생성자 자동 생성

  핵심 질문:
    "왜 생성자 주입을 권장하는가?"


4. Spring MVC 요청 흐름
----------------------------------------------------------------
  요청 → DispatcherServlet → HandlerMapping → Controller
       → Service → Mapper → DB
       → 응답 역순

  - @RequestBody  : JSON → Java 객체 (역직렬화)
  - @ResponseBody : Java 객체 → JSON (직렬화)
  - @RestController = @Controller + @ResponseBody
  - DTO로 요청/응답 데이터 분리 (Entity 직접 노출 금지)

  핵심 질문:
    "DispatcherServlet이 하는 역할은?"


5. Spring Security + JWT
----------------------------------------------------------------
  - 필터 체인 구조: 요청이 Controller 도달 전에 Security 필터 통과
  - JWT 흐름:
      로그인 → 토큰 발급 → 요청마다 헤더에 토큰 첨부
      → JwtFilter에서 토큰 검증 → SecurityContext에 인증 정보 세팅
  - 권한 처리: @PreAuthorize, SecurityContext의 Authentication 객체

  핵심 질문:
    "JWT 토큰 검증은 어느 시점에, 어디서 이루어지는가?"


================================================================
실무 직결 (6~10)
================================================================

6. @Scheduled 스케줄러
----------------------------------------------------------------
  - cron 표현식: "초 분 시 일 월 요일"
    예) "0 0/5 * * * *" → 5분마다 실행
  - 현업 활용: 실패한 외부 API 동기화 자동 재시도
  - 주의: 단일 스레드 기본 → 오래 걸리는 작업은 @Async 병행

  핵심 질문:
    "스케줄러가 실행 중에 다음 스케줄이 도래하면 어떻게 되는가?"


7. 트랜잭션 전파 (Propagation)
----------------------------------------------------------------
  - REQUIRED (기본값): 기존 트랜잭션 있으면 참여, 없으면 새로 생성
    → 실패 시 전체 롤백
  - REQUIRES_NEW: 무조건 새 트랜잭션 생성, 기존 트랜잭션과 독립
    → 외부 API 호출 결과를 별도 저장할 때 사용
  - 현업 활용: SAP API 호출 성공/실패 이력을 메인 트랜잭션과 분리 저장

  핵심 질문:
    "REQUIRES_NEW로 분리한 트랜잭션은 메인 트랜잭션 롤백에 영향받는가?"


8. 커넥션 풀 (HikariCP)
----------------------------------------------------------------
  - DB 연결을 미리 생성해두고 재사용 (연결 비용 절감)
  - maximum-pool-size: 최대 동시 DB 연결 수
  - connection-timeout: 커넥션 대기 최대 시간
  - 문제 상황:
      @Transactional 메서드 안에서 외부 API 5분 대기
      → 그 동안 커넥션 1개 점유
      → 동시 요청 많으면 커넥션 고갈 → 전체 서비스 장애

  핵심 질문:
    "커넥션 풀 고갈은 어떤 상황에서 발생하는가?"


9. 예외 처리 전략
----------------------------------------------------------------
  - @ControllerAdvice + @ExceptionHandler: 전역 예외 처리
  - Unchecked Exception (RuntimeException): @Transactional 기본 롤백 대상
  - Checked Exception (Exception): 기본적으로 롤백 안 됨
    → rollbackFor = Exception.class 명시 필요
  - 현업 주의: catch로 예외를 삼키면 트랜잭션이 롤백 안 됨

  핵심 질문:
    "Checked Exception 발생 시 트랜잭션이 롤백되지 않는 이유는?"


10. @Async + 외부 API 호출
----------------------------------------------------------------
  - @Async: 별도 스레드에서 비동기 실행
    → 호출한 메서드의 트랜잭션과 완전히 분리됨
  - 외부 API(SAP 등)를 트랜잭션 밖으로 빼는 패턴:
      1) DB 저장 (트랜잭션 커밋)
      2) @Async로 외부 API 호출
      3) 실패 시 sync_status = 'FAILED' 기록 → 재시도 스케줄러
  - @EnableAsync: 메인 클래스 또는 설정 클래스에 선언 필요

  핵심 질문:
    "@Async 메서드가 같은 클래스 안에 있으면 왜 동작 안 하는가?"
    (→ @Transactional과 같은 이유: 프록시 Self-Invocation 문제)

================================================================
실무 심화 (11~20)
================================================================

11. 낙관적 락 vs 비관적 락
----------------------------------------------------------------
  - 비관적 락 (SELECT FOR UPDATE)
      → "내가 읽는 순간 다른 트랜잭션 접근 차단"
      → DB 레벨에서 물리적으로 잠금
      → 충돌이 자주 발생하는 경우 적합 (정산, 재고 차감)
  - 낙관적 락 (@Version)
      → 잠금 없이 읽고, 저장 시 버전 비교
      → 버전 불일치 시 OptimisticLockException 발생 → 재시도
      → 충돌이 드문 경우 적합 (브랜드 수정 등)
  - 현업 활용: 브랜드 동시 수정 방지에 @Version 적용

  핵심 질문:
    "낙관적 락은 DB에 잠금을 걸지 않는데 어떻게 동시성을 보장하는가?"


12. Spring AOP 개념
----------------------------------------------------------------
  - @Transactional, @Async, @Scheduled 모두 AOP 기반 프록시로 동작
  - Advice(언제), Pointcut(어디서), JoinPoint(실행 지점)
  - @Around, @Before, @After
  - 실무 활용: 공통 로깅, 실행 시간 측정, 권한 체크
  - Self-Invocation 문제의 근본 원인이 AOP 프록시 구조

  핵심 질문:
    "@Transactional이 프록시로 동작한다는 게 정확히 무슨 의미인가?"


13. MyBatis 동적 SQL
----------------------------------------------------------------
  - <if test="...">     : 조건부 SQL
  - <choose><when>      : switch-case 패턴
  - <foreach>           : IN 절, 배열 반복
  - <where>, <set>      : 앞뒤 공백/쉼표 자동 처리
  - 현업 활용: 검색 조건이 가변적인 관리자 조회 쿼리

  핵심 질문:
    "<where> 태그가 없으면 동적 조건에서 어떤 문제가 생기는가?"


14. 공통 응답 포맷 + @RestControllerAdvice
----------------------------------------------------------------
  - 모든 API 응답을 일관된 구조로 감쌈
    예) { "code": "200", "message": "OK", "data": {...} }
  - @RestControllerAdvice: 전역 예외를 잡아서 공통 에러 응답 반환
  - 현업에서 프론트가 항상 같은 구조를 기대하므로 필수 패턴

  핵심 질문:
    "@ControllerAdvice와 @RestControllerAdvice의 차이는?"


15. Spring Boot 자동설정 (AutoConfiguration)
----------------------------------------------------------------
  - spring-boot-starter-* 의존성 추가만으로 설정 없이 동작하는 이유
  - @EnableAutoConfiguration → spring.factories → 조건부 빈 등록
  - @ConditionalOnClass, @ConditionalOnMissingBean
  - application.yml로 자동설정 값 오버라이드 가능

  핵심 질문:
    "DataSource 설정을 application.yml에만 써도 DB 연결이 되는 이유는?"


16. 페이징 처리 (MyBatis + LIMIT/OFFSET)
----------------------------------------------------------------
  - 관리자 그리드에서 필수
  - MyBatis에서 페이징 쿼리:
      SELECT * FROM table LIMIT #{size} OFFSET #{offset}
  - 전체 건수 쿼리(COUNT)와 목록 쿼리 2번 실행
  - PageHelper 플러그인으로 자동 처리 가능
  - offset = (page - 1) * size

  핵심 질문:
    "페이지 번호가 뒤로 갈수록 OFFSET 방식이 느려지는 이유는?"


17. 환경별 설정 (Profiles)
----------------------------------------------------------------
  - application.yml, application-dev.yml, application-prod.yml
  - spring.profiles.active=dev 로 활성 프로파일 지정
  - DB URL, 외부 API URL, 로그 레벨을 환경별로 다르게
  - 현업: 개발 서버 / 스테이징 / 운영 환경 분리

  핵심 질문:
    "운영 환경에서 DB 비밀번호를 application.yml에 직접 쓰면 안 되는 이유는?"


18. Lombok 주요 어노테이션
----------------------------------------------------------------
  - @Getter / @Setter          : getter/setter 자동 생성
  - @NoArgsConstructor         : 기본 생성자
  - @AllArgsConstructor        : 전체 필드 생성자
  - @RequiredArgsConstructor   : final 필드 생성자 (DI에 활용)
  - @Builder                   : 빌더 패턴
  - @Data                      : @Getter + @Setter + @ToString + @EqualsAndHashCode
  - @Slf4j                     : log 필드 자동 생성

  핵심 질문:
    "@Data를 Entity에 쓰면 안 되는 이유는?"


19. Filter vs Interceptor vs AOP
----------------------------------------------------------------
  요청 처리 순서:
    Filter → DispatcherServlet → Interceptor → Controller → AOP → Service

  - Filter: Servlet 레벨, Spring 밖, 인코딩/CORS/보안
  - Interceptor: Spring MVC 레벨, 로그인 체크, 공통 처리
  - AOP: 메서드 레벨, 트랜잭션/로깅/권한

  현업 활용:
    JWT 검증 → Security Filter
    API 실행 로그 → Interceptor or AOP

  핵심 질문:
    "JWT 검증을 Interceptor가 아닌 Filter에서 하는 이유는?"


20. Spring Boot DevTools + 개발 편의 기능
----------------------------------------------------------------
  - spring-boot-devtools: 코드 변경 시 자동 재시작
  - LiveReload: 브라우저 자동 새로고침
  - spring-boot-docker-compose: 앱 실행 시 compose.yaml 자동으로 DB 컨테이너 기동
    (현업 프로젝트에서 이미 사용 중)
  - @ConfigurationProperties: 타입 안전한 설정 값 바인딩
  - Actuator: 운영 중 앱 상태 모니터링 엔드포인트 제공

  핵심 질문:
    "DevTools의 자동 재시작이 일반 재시작보다 빠른 이유는?"

================================================================
테스트 코드 (21~25)
================================================================

21. JUnit5 + Spring Boot 테스트 기본 구조
----------------------------------------------------------------
  - @SpringBootTest       : 전체 ApplicationContext 로드 (통합 테스트)
  - @WebMvcTest           : Controller 레이어만 로드
  - @DataJpaTest          : DB 레이어만 로드
  - @ExtendWith(SpringExtension.class): JUnit5와 Spring 연동
  - @MockitoBean          : Spring 컨텍스트의 특정 빈을 Mock으로 교체
    (현업 프로젝트 FnbMiniApplicationTests에서 직접 사용)

  핵심 질문:
    "@SpringBootTest와 @WebMvcTest의 차이와 각각 언제 쓰는가?"


22. Mockito — 단위 테스트의 핵심
----------------------------------------------------------------
  - @Mock        : 순수 Mock 객체 (Spring 컨텍스트 없이)
  - @InjectMocks : Mock을 주입받는 테스트 대상 객체
  - when(...).thenReturn(...) : 메서드 반환값 지정
  - verify(...)  : 특정 메서드가 호출됐는지 검증
  - @Spy         : 실제 객체이지만 일부 메서드만 Mock 처리

  핵심 질문:
    "@Mock과 @MockitoBean의 차이는?"


23. 동시성 테스트 (CountDownLatch + ExecutorService)
----------------------------------------------------------------
  - 동시성 문제를 코드로 재현하는 핵심 도구
  - CountDownLatch: 여러 스레드가 동시에 시작하도록 대기
  - ExecutorService: 스레드 풀로 병렬 실행

  예시:
    int threadCount = 10;
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
        executor.submit(() -> {
            latch.countDown();
            latch.await();      // 모두 준비될 때까지 대기
            settlementService.settle(dto);  // 동시 실행
        });
    }

  - SELECT FOR UPDATE 적용 전후를 이 테스트로 비교 검증
  - 현업 정산 동시성 문제를 이 방법으로 증명 가능

  핵심 질문:
    "CountDownLatch 없이 그냥 스레드를 여러 개 띄우면 진짜 동시에 실행되지 않는 이유는?"


24. 통합 테스트 vs 단위 테스트 전략
----------------------------------------------------------------
  - 단위 테스트: Service/Mapper 각각 격리해서 빠르게 검증
      → Mock으로 DB 없이 실행
  - 통합 테스트: 실제 DB와 연동해서 전체 흐름 검증
      → @SpringBootTest + 실제 DB (또는 Testcontainers)
  - 테스트 피라미드: 단위 > 통합 > E2E 순으로 비중 유지
  - 현업 SI에서는 통합 테스트도 드물지만,
    동시성 문제 검증은 통합 테스트로만 가능

  핵심 질문:
    "단위 테스트만으로 동시성 문제를 검증할 수 없는 이유는?"


25. Testcontainers — 테스트용 DB 자동 관리
----------------------------------------------------------------
  - 테스트 실행 시 Docker로 PostgreSQL 컨테이너를 자동으로 띄우고 종료
  - 실제 DB와 동일한 환경에서 테스트 가능
  - CI/CD 파이프라인에서 DB 없이도 통합 테스트 실행 가능
  - 의존성: org.testcontainers:postgresql

  예시:
    @Container
    static PostgreSQLContainer<?> postgres =
        new PostgreSQLContainer<>("postgres:15");

  - 현재 미니 프로젝트에서 mvn test 시 DB 없이 실패하는 문제의 근본 해결책

  핵심 질문:
    "@MockitoBean으로 Mapper를 목 처리하는 것과 Testcontainers의 차이는?"


================================================================
성능 최적화 (26~30)
================================================================

26. N+1 문제
----------------------------------------------------------------
  - 1번 조회 후 결과 N건에 대해 N번 추가 쿼리가 실행되는 문제
  - MyBatis에서는 resultMap의 <collection> 사용 시 주의
  - 해결책:
      JOIN으로 한 번에 조회
      또는 IN 절로 한 번에 조회 (배치 로딩)
  - 관리자 목록 조회에서 자주 발생

  핵심 질문:
    "N+1이 왜 문제인지 쿼리 실행 수로 설명하면?"


27. DB 인덱스 기초
----------------------------------------------------------------
  - 인덱스 없는 컬럼을 WHERE 조건으로 쓰면 Full Table Scan
  - 자주 조회하는 컬럼(매장코드, 정산일자, 사용자ID)에 인덱스 추가
  - 복합 인덱스: 순서가 중요 (선두 컬럼부터 사용)
  - 인덱스가 너무 많으면 INSERT/UPDATE 성능 저하
  - EXPLAIN으로 실행 계획 확인

  핵심 질문:
    "인덱스가 있어도 쿼리가 느린 경우는 어떤 상황인가?"


28. 캐싱 (@Cacheable)
----------------------------------------------------------------
  - 자주 조회되고 잘 안 바뀌는 데이터를 메모리에 저장
  - @EnableCaching + @Cacheable("menuList")
  - @CacheEvict: 데이터 변경 시 캐시 삭제
  - 현업 활용: 메뉴 목록은 로그인 때마다 DB 조회 → 캐싱 적합
  - 주의: 캐시된 데이터와 DB 데이터 불일치 (Cache Staleness)

  핵심 질문:
    "@Cacheable과 @CacheEvict를 함께 쓰지 않으면 어떤 문제가 생기는가?"


29. 커넥션 풀 튜닝 + 슬로우 쿼리 대응
----------------------------------------------------------------
  - hikari.maximum-pool-size: CPU 코어 수 * 2 + 유효 디스크 수가 일반적 기준
  - 슬로우 쿼리 로그 설정:
      logging.level.org.mybatis: DEBUG → SQL + 실행 시간 확인
  - 오래 걸리는 쿼리 원인:
      인덱스 누락, N+1, 불필요한 전체 조회, 정렬 없는 페이징
  - 외부 API 호출을 트랜잭션 안에 두면 커넥션 점유 시간 급증
    (현업 SAP 5분 타임아웃 문제와 직결)

  핵심 질문:
    "커넥션 풀 사이즈를 무작정 크게 늘리면 안 되는 이유는?"


30. 페이징 성능 — OFFSET 방식의 한계와 대안
----------------------------------------------------------------
  - OFFSET이 크면 DB가 앞 데이터를 전부 읽고 버림 → 뒤 페이지일수록 느림
  - 해결책: 커서 기반 페이징 (No-Offset)
      WHERE id < #{lastId} ORDER BY id DESC LIMIT #{size}
      → 마지막으로 읽은 ID 기준으로 다음 페이지 조회
  - 관리자 페이지처럼 페이지 번호 직접 이동이 필요하면 OFFSET 불가피
  - 데이터 건수가 수만 건 이상이면 커서 기반 고려

  핵심 질문:
    "커서 기반 페이징은 특정 페이지 번호로 바로 이동이 왜 어려운가?"

================================================================
