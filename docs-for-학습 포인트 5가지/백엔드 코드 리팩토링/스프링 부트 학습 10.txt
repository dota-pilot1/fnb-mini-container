================================================================
실무 백엔드(Spring Boot + MyBatis) 이해를 위한 핵심 20가지
================================================================

================================================================
기본 구조 (1~5)
================================================================

1. @Transactional 동작 원리
----------------------------------------------------------------
  - Spring은 @Transactional을 프록시 객체로 감싸서 처리
  - 같은 클래스 내에서 자기 메서드를 호출하면 프록시를 거치지 않음
    → 트랜잭션이 적용 안 됨 (Self-Invocation 문제)
  - 해결책: Self-Proxy 패턴 (자기 자신을 @Autowired로 주입)
  - 현업 코드에서 직접 등장한 패턴 (CrdtCardAck)

  핵심 질문:
    "왜 같은 클래스 안에서 호출하면 @Transactional이 안 먹히나?"


2. MyBatis 동작 방식
----------------------------------------------------------------
  - Mapper 인터페이스 → XML(SQL) → DB 순으로 실행
  - SqlSession이 DB 연결을 담당
  - #{} : PreparedStatement (SQL 인젝션 방지, 값 바인딩)
  - ${} : 문자열 직접 치환 (테이블명, 컬럼명 동적 처리 시 사용, 위험)
  - resultMap : DB 컬럼명과 Java 필드명 매핑 (snake_case → camelCase)
  - map-underscore-to-camel-case: true 설정으로 자동 변환 가능

  핵심 질문:
    "#{} 와 ${} 의 차이와 각각 언제 쓰는가?"


3. Spring Bean 생명주기 + DI
----------------------------------------------------------------
  - @Component, @Service, @Repository, @Controller
    → 전부 Bean 등록이지만 계층별 의미 구분
  - 생성자 주입 (권장): 불변성 보장, 테스트 용이
  - 필드 주입 (@Autowired): 간편하지만 테스트 어려움
  - @RequiredArgsConstructor (Lombok): final 필드 생성자 자동 생성

  핵심 질문:
    "왜 생성자 주입을 권장하는가?"


4. Spring MVC 요청 흐름
----------------------------------------------------------------
  요청 → DispatcherServlet → HandlerMapping → Controller
       → Service → Mapper → DB
       → 응답 역순

  - @RequestBody  : JSON → Java 객체 (역직렬화)
  - @ResponseBody : Java 객체 → JSON (직렬화)
  - @RestController = @Controller + @ResponseBody
  - DTO로 요청/응답 데이터 분리 (Entity 직접 노출 금지)

  핵심 질문:
    "DispatcherServlet이 하는 역할은?"


5. Spring Security + JWT
----------------------------------------------------------------
  - 필터 체인 구조: 요청이 Controller 도달 전에 Security 필터 통과
  - JWT 흐름:
      로그인 → 토큰 발급 → 요청마다 헤더에 토큰 첨부
      → JwtFilter에서 토큰 검증 → SecurityContext에 인증 정보 세팅
  - 권한 처리: @PreAuthorize, SecurityContext의 Authentication 객체

  핵심 질문:
    "JWT 토큰 검증은 어느 시점에, 어디서 이루어지는가?"


================================================================
실무 직결 (6~10)
================================================================

6. @Scheduled 스케줄러
----------------------------------------------------------------
  - cron 표현식: "초 분 시 일 월 요일"
    예) "0 0/5 * * * *" → 5분마다 실행
  - 현업 활용: 실패한 외부 API 동기화 자동 재시도
  - 주의: 단일 스레드 기본 → 오래 걸리는 작업은 @Async 병행

  핵심 질문:
    "스케줄러가 실행 중에 다음 스케줄이 도래하면 어떻게 되는가?"


7. 트랜잭션 전파 (Propagation)
----------------------------------------------------------------
  - REQUIRED (기본값): 기존 트랜잭션 있으면 참여, 없으면 새로 생성
    → 실패 시 전체 롤백
  - REQUIRES_NEW: 무조건 새 트랜잭션 생성, 기존 트랜잭션과 독립
    → 외부 API 호출 결과를 별도 저장할 때 사용
  - 현업 활용: SAP API 호출 성공/실패 이력을 메인 트랜잭션과 분리 저장

  핵심 질문:
    "REQUIRES_NEW로 분리한 트랜잭션은 메인 트랜잭션 롤백에 영향받는가?"


8. 커넥션 풀 (HikariCP)
----------------------------------------------------------------
  - DB 연결을 미리 생성해두고 재사용 (연결 비용 절감)
  - maximum-pool-size: 최대 동시 DB 연결 수
  - connection-timeout: 커넥션 대기 최대 시간
  - 문제 상황:
      @Transactional 메서드 안에서 외부 API 5분 대기
      → 그 동안 커넥션 1개 점유
      → 동시 요청 많으면 커넥션 고갈 → 전체 서비스 장애

  핵심 질문:
    "커넥션 풀 고갈은 어떤 상황에서 발생하는가?"


9. 예외 처리 전략
----------------------------------------------------------------
  - @ControllerAdvice + @ExceptionHandler: 전역 예외 처리
  - Unchecked Exception (RuntimeException): @Transactional 기본 롤백 대상
  - Checked Exception (Exception): 기본적으로 롤백 안 됨
    → rollbackFor = Exception.class 명시 필요
  - 현업 주의: catch로 예외를 삼키면 트랜잭션이 롤백 안 됨

  핵심 질문:
    "Checked Exception 발생 시 트랜잭션이 롤백되지 않는 이유는?"


10. @Async + 외부 API 호출
----------------------------------------------------------------
  - @Async: 별도 스레드에서 비동기 실행
    → 호출한 메서드의 트랜잭션과 완전히 분리됨
  - 외부 API(SAP 등)를 트랜잭션 밖으로 빼는 패턴:
      1) DB 저장 (트랜잭션 커밋)
      2) @Async로 외부 API 호출
      3) 실패 시 sync_status = 'FAILED' 기록 → 재시도 스케줄러
  - @EnableAsync: 메인 클래스 또는 설정 클래스에 선언 필요

  핵심 질문:
    "@Async 메서드가 같은 클래스 안에 있으면 왜 동작 안 하는가?"
    (→ @Transactional과 같은 이유: 프록시 Self-Invocation 문제)

================================================================
실무 심화 (11~20)
================================================================

11. 낙관적 락 vs 비관적 락
----------------------------------------------------------------
  - 비관적 락 (SELECT FOR UPDATE)
      → "내가 읽는 순간 다른 트랜잭션 접근 차단"
      → DB 레벨에서 물리적으로 잠금
      → 충돌이 자주 발생하는 경우 적합 (정산, 재고 차감)
  - 낙관적 락 (@Version)
      → 잠금 없이 읽고, 저장 시 버전 비교
      → 버전 불일치 시 OptimisticLockException 발생 → 재시도
      → 충돌이 드문 경우 적합 (브랜드 수정 등)
  - 현업 활용: 브랜드 동시 수정 방지에 @Version 적용

  핵심 질문:
    "낙관적 락은 DB에 잠금을 걸지 않는데 어떻게 동시성을 보장하는가?"


12. Spring AOP 개념
----------------------------------------------------------------
  - @Transactional, @Async, @Scheduled 모두 AOP 기반 프록시로 동작
  - Advice(언제), Pointcut(어디서), JoinPoint(실행 지점)
  - @Around, @Before, @After
  - 실무 활용: 공통 로깅, 실행 시간 측정, 권한 체크
  - Self-Invocation 문제의 근본 원인이 AOP 프록시 구조

  핵심 질문:
    "@Transactional이 프록시로 동작한다는 게 정확히 무슨 의미인가?"


13. MyBatis 동적 SQL
----------------------------------------------------------------
  - <if test="...">     : 조건부 SQL
  - <choose><when>      : switch-case 패턴
  - <foreach>           : IN 절, 배열 반복
  - <where>, <set>      : 앞뒤 공백/쉼표 자동 처리
  - 현업 활용: 검색 조건이 가변적인 관리자 조회 쿼리

  핵심 질문:
    "<where> 태그가 없으면 동적 조건에서 어떤 문제가 생기는가?"


14. 공통 응답 포맷 + @RestControllerAdvice
----------------------------------------------------------------
  - 모든 API 응답을 일관된 구조로 감쌈
    예) { "code": "200", "message": "OK", "data": {...} }
  - @RestControllerAdvice: 전역 예외를 잡아서 공통 에러 응답 반환
  - 현업에서 프론트가 항상 같은 구조를 기대하므로 필수 패턴

  핵심 질문:
    "@ControllerAdvice와 @RestControllerAdvice의 차이는?"


15. Spring Boot 자동설정 (AutoConfiguration)
----------------------------------------------------------------
  - spring-boot-starter-* 의존성 추가만으로 설정 없이 동작하는 이유
  - @EnableAutoConfiguration → spring.factories → 조건부 빈 등록
  - @ConditionalOnClass, @ConditionalOnMissingBean
  - application.yml로 자동설정 값 오버라이드 가능

  핵심 질문:
    "DataSource 설정을 application.yml에만 써도 DB 연결이 되는 이유는?"


16. 페이징 처리 (MyBatis + LIMIT/OFFSET)
----------------------------------------------------------------
  - 관리자 그리드에서 필수
  - MyBatis에서 페이징 쿼리:
      SELECT * FROM table LIMIT #{size} OFFSET #{offset}
  - 전체 건수 쿼리(COUNT)와 목록 쿼리 2번 실행
  - PageHelper 플러그인으로 자동 처리 가능
  - offset = (page - 1) * size

  핵심 질문:
    "페이지 번호가 뒤로 갈수록 OFFSET 방식이 느려지는 이유는?"


17. 환경별 설정 (Profiles)
----------------------------------------------------------------
  - application.yml, application-dev.yml, application-prod.yml
  - spring.profiles.active=dev 로 활성 프로파일 지정
  - DB URL, 외부 API URL, 로그 레벨을 환경별로 다르게
  - 현업: 개발 서버 / 스테이징 / 운영 환경 분리

  핵심 질문:
    "운영 환경에서 DB 비밀번호를 application.yml에 직접 쓰면 안 되는 이유는?"


18. Lombok 주요 어노테이션
----------------------------------------------------------------
  - @Getter / @Setter          : getter/setter 자동 생성
  - @NoArgsConstructor         : 기본 생성자
  - @AllArgsConstructor        : 전체 필드 생성자
  - @RequiredArgsConstructor   : final 필드 생성자 (DI에 활용)
  - @Builder                   : 빌더 패턴
  - @Data                      : @Getter + @Setter + @ToString + @EqualsAndHashCode
  - @Slf4j                     : log 필드 자동 생성

  핵심 질문:
    "@Data를 Entity에 쓰면 안 되는 이유는?"


19. Filter vs Interceptor vs AOP
----------------------------------------------------------------
  요청 처리 순서:
    Filter → DispatcherServlet → Interceptor → Controller → AOP → Service

  - Filter: Servlet 레벨, Spring 밖, 인코딩/CORS/보안
  - Interceptor: Spring MVC 레벨, 로그인 체크, 공통 처리
  - AOP: 메서드 레벨, 트랜잭션/로깅/권한

  현업 활용:
    JWT 검증 → Security Filter
    API 실행 로그 → Interceptor or AOP

  핵심 질문:
    "JWT 검증을 Interceptor가 아닌 Filter에서 하는 이유는?"


20. Spring Boot DevTools + 개발 편의 기능
----------------------------------------------------------------
  - spring-boot-devtools: 코드 변경 시 자동 재시작
  - LiveReload: 브라우저 자동 새로고침
  - spring-boot-docker-compose: 앱 실행 시 compose.yaml 자동으로 DB 컨테이너 기동
    (현업 프로젝트에서 이미 사용 중)
  - @ConfigurationProperties: 타입 안전한 설정 값 바인딩
  - Actuator: 운영 중 앱 상태 모니터링 엔드포인트 제공

  핵심 질문:
    "DevTools의 자동 재시작이 일반 재시작보다 빠른 이유는?"

================================================================
