useQuery 를 이해해 보자
===========================================================
/**
 * 브랜드 목록 조회
 * enabled: false → 검색 버튼 클릭 시 refetch() 호출로 실행
 */
export function useBrandList(params) {
  return useQuery({
    queryKey: brandKeys.list(params),
    queryFn: () => fetchBrandList(params),
    enabled: false,
    select: (res) => res.data ?? [],
  })
===========================================================

▶ 각 속성 설명
-----------------------------------------------------------

1. queryKey: brandKeys.list(params)
-----------------------------------------------------------
  TanStack Query의 캐시 식별자.
  이 키가 같으면 같은 캐시로 취급하고, 다르면 새 요청을 보낸다.

  brandKeys.list(params) 의 실제 값은:
    ['brands', 'list', { brandCode: 'A001', useYn: 'Y' }]  ← 이런 배열

  params가 바뀌면 키가 바뀌므로 → 자동으로 새 요청 발생.
  params가 같으면 키가 같으므로 → 캐시에서 꺼내서 반환.

  실무 팁: 도메인 > 종류 > 조건 순으로 계층화하는 게 관례.
    brandKeys = {
      all:  ['brands'],
      list: (params) => ['brands', 'list', params],
    }


2. queryFn: () => fetchBrandList(params)
-----------------------------------------------------------
  실제 서버 호출 함수. Promise를 반환해야 한다.
  성공 시 resolve된 값이 data로 들어오고,
  실패 시 reject된 값이 error로 들어온다.

  왜 () => 로 감싸나?
    → params를 클로저로 캡처해서 queryKey가 바뀔 때마다
      최신 params로 호출되도록 하기 위함.
    → fetchBrandList(params) 라고 직접 쓰면
      함수가 아니라 Promise가 전달되어 버림.


3. enabled: false
-----------------------------------------------------------
  기본값은 true → 컴포넌트가 마운트되는 순간 자동으로 queryFn 실행.
  false로 설정하면 자동 실행을 끈다.

  이 프로젝트처럼 "검색 버튼을 눌러야만 조회"하는 패턴에서 사용.
  refetch() 를 직접 호출해야만 요청이 나간다.

  자동 실행이 필요한 경우 (ex. 페이지 진입 시 즉시 조회):
    enabled: true  또는 그냥 삭제 (기본값이 true)

  조건부 실행 패턴:
    enabled: !!userId   ← userId가 있을 때만 실행


4. select: (res) => res.data ?? []
-----------------------------------------------------------
  서버 응답(res)에서 실제로 사용할 데이터만 추출하는 변환 함수.
  queryFn이 반환한 값을 가공해서 data에 담아준다.

  이 프로젝트 서버 응답 구조:
    { success: true, message: '...', data: [...] }
                                      ↑ 이것만 필요

  select 없이 쓰면:
    const { data } = useBrandList(params)
    data.data  ← 이렇게 꺼내야 함 (번거로움)

  select 있으면:
    const { data } = useBrandList(params)
    data  ← 바로 배열

  ?? [] 의 의미: res.data가 null/undefined 이면 빈 배열로 fallback


-----------------------------------------------------------
▶ useQuery가 반환하는 주요 값
-----------------------------------------------------------

  const {
    data,        // queryFn 성공 시 결과 (select 적용 후)
    isFetching,  // 현재 네트워크 요청 중 (백그라운드 포함)
    isLoading,   // 최초 로딩 중 (캐시 없음 + 요청 중)
    isError,     // 에러 발생 여부
    error,       // 에러 객체
    refetch,     // 수동으로 다시 요청 트리거
  } = useBrandList(params)

  isFetching vs isLoading 차이:
    isLoading  → 캐시에 데이터가 전혀 없고, 지금 요청 중인 상태
    isFetching → 캐시 유무 상관없이, 지금 네트워크 요청이 나가고 있는 상태
    (백그라운드 재요청 시: isFetching=true, isLoading=false)


-----------------------------------------------------------
▶ 사용법 (이 프로젝트 패턴)
-----------------------------------------------------------

// 1. hook 정의 (src/hooks/brand/use-brand-queries.js)
export function useBrandList(params) {
  return useQuery({
    queryKey: brandKeys.list(params),
    queryFn: () => fetchBrandList(params),
    enabled: false,
    select: (res) => res.data ?? [],
  })
}

// 2. 페이지에서 사용 (BrandPage.jsx)
const [searchParams, setSearchParams] = useState({})

const { data: brandList = [], isFetching, refetch } = useBrandList(searchParams)

const handleSearch = () => {
  const cleanParams = Object.fromEntries(
    Object.entries(getValues()).filter(([, v]) => v !== '')
  )
  setSearchParams(cleanParams)         // ① queryKey 업데이트
  setTimeout(() => refetch(), 0)       // ② 다음 틱에서 최신 key로 요청
}

// ※ setTimeout이 필요한 이유:
//   setSearchParams는 비동기(React 배치 업데이트).
//   같은 틱에서 바로 refetch()를 호출하면
//   searchParams가 아직 이전 값이라 queryKey가 안 바뀐 채로 요청됨.
//   setTimeout으로 한 틱 뒤에 호출하면
//   리렌더링이 완료된 후 refetch()가 실행되어 최신 queryKey 반영.
