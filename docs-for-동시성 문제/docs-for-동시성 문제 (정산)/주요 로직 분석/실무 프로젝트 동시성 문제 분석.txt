================================================================
실무 프로젝트 — 결제/정산 영역의 동시성 문제 분석
================================================================

브랜드 관리는 관리자 몇 명이 쓰는 데이터라 조치가 간단했음.
실무에서 진짜 복잡한 곳은 "정산(Settlement)" 영역.
매출 등록, 신용카드 정산, SAP 연동이 얽혀 있음.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 매출등록 정산 (PosSalesReg) — 가장 위험한 부분

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 6단계 트랜잭션 (하나의 @Transactional 안에서)

  1) insertReversePosSales()  → 취소용 역분개 데이터 생성
  2) insertDelTFMCL006()      → 취소용 전표(G/L) 생성
  3) deleteTFMCL006()         → 원본 전표 삭제 표시
  4) deletePosSales()         → 원본 매출 삭제 표시
  5) insertPosSales()         → 새 매출 데이터 생성
  6) insertTFMCL006()         → 새 전표 생성

  + SAP EAI 외부 API 호출 (moduleCallEAI) 2회

■ 문제점

  - 6단계가 하나의 @Transactional → 하나라도 실패하면 전부 롤백
  - SAP API 호출이 트랜잭션 안에 있음 (브랜드 관리와 같은 문제!)
  - SAP 타임아웃 5분 → 그 동안 DB 커넥션 점유
  - 수정 대상 데이터에 SELECT FOR UPDATE 없음
    → 동시에 같은 매출 데이터를 정산하면 데이터 꼬임 가능
  - 멱등성 없음 → SAP API 중복 호출 시 이중 정산 위험

■ 파일
  - PosSalesRegService.java (라인 310-388)
  - PosSalesRegMapper.xml (라인 1055-1940)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2. 신용카드 정산 (CrdtCardAckGdohReg)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 패턴: Check-Then-Act (검사 후 실행)

  list = mapper.crdtCardAckGdohRegLst(dto);
  if (!ObjectUtils.isEmpty(list)) {
      throw new Exception("이미 존재");
  } else {
      self.insertCrdtCardAck(dto);    // ← self 주입 사용!
  }

■ 문제점

  - 조회와 삽입 사이에 락이 없음
  - A, B가 동시에 조회 → 둘 다 "없음" → 둘 다 INSERT
    → 중복 정산 데이터 발생 가능

■ 잘 된 점
  - self 주입 패턴 사용 (트랜잭션 경계 분리)

■ 파일
  - CrdtCardAckGdohRegService.java (라인 173-180)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

3. POS 개점/마감 (Adapter)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 패턴: Check-Then-Act (동일)

  posStatus = mapper.getFscpsPosStatus(...);
  if (posStatus.getSodYn() == "Y") {
      // 이미 개점 → 에러
  } else {
      mapper.updatePosOpen(...);   // 개점 처리
  }

■ 문제점

  - 상태 확인 시점과 업데이트 시점 사이에 락 없음
  - 두 요청이 동시에 "미개점" 확인 → 둘 다 개점 처리
  - POS 상태 정합성 깨질 수 있음

■ 파일
  - AdapterService.java (라인 127-222)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

4. SAP EAI 외부 API 연동

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

■ 현재 구현

  - 동기 호출 (Synchronous SOAP)
  - 타임아웃: 5분 (300,000ms)
  - 기본 인증 (HTTP Basic Auth)
  - 재시도 없음
  - 서킷 브레이커 없음
  - 멱등성 키 없음

■ 문제점

  - SAP 장애 시 5분간 커넥션 + 스레드 점유
  - 실패해도 재시도 불가 (이력 없음)
  - 같은 요청 중복 호출 방지 장치 없음
  - 정산 트랜잭션 안에서 호출 → SAP 실패 = 전체 롤백

■ 파일
  - SI_COM0280_FS_ClientSynchronousModule.java (라인 79-376)
  - Com0280Service.java


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

5. 재고 관리 — 실무에는 거의 없음

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  실무 프로젝트(FSCPS BO)는 재고 차감 로직이 없음.
  POS 시스템이 재고를 관리하고, BO는 정산/리포트 역할.
  사전상품(PreOrder)도 신청 관리만 있고 재고 할당 로직 없음.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

실무에서 발견된 동시성 위험 요약

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ┌─────────────────────┬────────┬──────────────────────────────┐
  │ 위험                 │ 심각도 │ 위치                          │
  ├─────────────────────┼────────┼──────────────────────────────┤
  │ 6단계 TX에 락 없음   │ 높음   │ PosSalesRegService           │
  │ SAP 호출이 TX 안     │ 높음   │ PosSalesRegService           │
  │ SAP 멱등성 없음      │ 높음   │ SAP EAI 모듈 전체            │
  │ Check-Then-Act 경합  │ 높음   │ AdapterService (POS 개점)    │
  │ Check-Then-Act 경합  │ 중간   │ CrdtCardAckGdohRegService    │
  │ 루프 개별 UPDATE     │ 낮음   │ MnulCustSalesRegService      │
  │ 재시도 없음          │ 중간   │ SAP EAI 전체                 │
  │ 서킷 브레이커 없음   │ 중간   │ SAP EAI 전체                 │
  └─────────────────────┴────────┴──────────────────────────────┘


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

브랜드 관리 vs 정산 — 필요한 조치 비교

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ┌──────────────────────┬────────────┬────────────┐
  │ 조치                  │ 브랜드 관리 │ 정산       │
  ├──────────────────────┼────────────┼────────────┤
  │ 트랜잭션 분리         │ ✅ 구현됨   │ ❌ 미구현   │
  │ 낙관적 락            │ ✅ 구현됨   │ ❌ 미구현   │
  │ 이력 테이블           │ ✅ 구현됨   │ ❌ 미구현   │
  │ 비관적 락 (FOR UPDATE)│ 불필요     │ ⚠️ 필요    │
  │ 멱등성 키            │ 불필요     │ ⚠️ 필요    │
  │ 보상 트랜잭션        │ 불필요     │ ⚠️ 필요    │
  │ 서킷 브레이커        │ 불필요     │ ⚠️ 필요    │
  │ 지수 백오프 재시도    │ 선택적     │ ⚠️ 필요    │
  └──────────────────────┴────────────┴────────────┘

  정산 영역은 금전 데이터를 다루므로 브랜드 관리보다
  훨씬 많은 동시성 조치가 필요하지만, 현재 실무에는
  대부분 미구현 상태 (TODO 수준).


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

정산에 이상적으로 필요한 추가 조치들

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  1. 비관적 락 (SELECT FOR UPDATE)
     → 6단계 정산 시작 전에 대상 매출 행을 잠금
     → 다른 트랜잭션이 같은 매출을 동시 처리 방지

  2. 멱등성 키
     → SAP EAI 호출 시 고유 키 부여
     → 같은 요청 중복 처리 방지 (이중 정산 차단)

  3. 보상 트랜잭션 (Compensating Transaction)
     → SAP 호출 성공 → DB 저장 실패 시 SAP에 취소 요청
     → 현재는 6단계 중 5단계 성공 + SAP 성공 → 6단계 실패
        = SAP에는 반영됐는데 DB에는 롤백 (데이터 불일치)

  4. 서킷 브레이커
     → SAP 장시간 다운 시 호출 자체를 차단
     → 5분 타임아웃 × 다수 요청 = 스레드 풀 고갈 방지

  5. 지수 백오프 재시도
     → SAP 일시적 장애 시 1분 → 5분 → 30분 간격 재시도
     → 현재는 실패하면 그냥 끝 (수동 재처리 필요)

  6. 트랜잭션 분리
     → 매출 등록(6단계)의 SAP 호출을 TX 밖으로
     → 브랜드 관리에서 한 것과 동일한 패턴 적용 필요
