================================================================
그 외 조취들 — 핵심 3개를 보완하는 부수적 조취
================================================================

핵심 조취 3개:
  1. 트랜잭션 분리 (커넥션 풀 고갈 방지)
  2. 낙관적 락 (동시 수정 충돌 감지)
  3. 이력 테이블 (동기화 결과 기록 + 상태 추적 + 재시도)

아래는 핵심 조취들이 제대로 동작하도록 받쳐주는 보완 조취들.
단독으로 의미 있는 게 아니라, 핵심 조취가 있어야 존재 이유가 생김.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 조취 ① Self-Proxy 패턴

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 대상: 핵심 1번 (트랜잭션 분리)

트랜잭션 3분할을 위해 같은 클래스 안에서
self.saveBrandsToDb() / self.updateSyncResults() 를 호출.
this로 호출하면 Spring AOP 프록시를 안 거쳐서 @Transactional 무시됨.
→ self 주입(@Lazy @Autowired)으로 프록시 경유 보장.

한 줄 요약: 트랜잭션 분리가 실제로 동작하게 만드는 기술적 수단.

파일: BrandService.java (라인 64-66)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 조취 ② 동기화 상태 추적 (sync_status)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 대상: 핵심 3번 (이력 테이블)

brand 테이블에 sync_status 컬럼: NONE → PENDING → SUCCESS / FAILED
→ 1차(DB 저장)에서 PENDING, 3차(결과 반영)에서 SUCCESS 또는 FAILED.
→ FAILED인 건만 골라서 재시도할 수 있게 해줌.

한 줄 요약: 이력 테이블에서 "뭐가 실패했는지" 빠르게 찾기 위한 상태 플래그.

파일: BrandMapper.xml (updateSyncStatus)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 조취 ③ 자동 재시도 (5분 스케줄러)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 대상: 핵심 3번 (이력 테이블)

sync_status='FAILED' + retry_count < 3인 건을 5분마다 자동 재시도.
이력 테이블에 실패 기록이 있으니까 재시도 대상을 찾을 수 있는 것.

한 줄 요약: 이력 테이블 덕분에 가능한 자동 복구 장치.

파일: BrandSyncScheduler.java


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 조취 ④ 수동 재시도 (POST /api/brands/{id}/retry)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 대상: 핵심 3번 (이력 테이블)

자동 재시도(5분)를 기다리지 않고 관리자가 즉시 재시도.
FAILED 상태 + retry_count < 3 조건 동일.

한 줄 요약: 자동 재시도의 수동 버전 (급할 때).

파일: BrandController.java, BrandService.java (retrySyncForBrand)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 조취 ⑤ 외부 API 에러 핸들링

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

보완 대상: 핵심 1번 (트랜잭션 분리) + 핵심 3번 (이력 테이블)

외부 API 에러 시 예외를 throw하지 않고 result에 담아서 반환.
→ throw하면 이력 테이블에 기록이 안 남음.
→ catch해서 success=false + errorMessage를 돌려주니까
   3차(updateSyncResults)에서 FAILED로 기록 + 이력 저장 가능.

또한 응답 코드 검증(0xxx=성공, 그 외=실패)도 여기서 처리.
실무에서는 이 검증이 빠져서 에러 응답도 성공으로 커밋됨.

한 줄 요약: 에러를 삼켜서 이력에 남기고, 재시도 가능하게 만드는 장치.

파일: ShopApiClient.java (callApi 메서드)


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

관계도 요약

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  핵심 1. 트랜잭션 분리
    ├─ 보완 ① Self-Proxy  → TX 분리가 실제로 동작하게
    └─ 보완 ⑤ 에러 핸들링 → 2차(API)에서 에러 나도 안전하게

  핵심 2. 낙관적 락
    └─ (보완 조취 없음, 단독으로 동작)

  핵심 3. 이력 테이블
    ├─ 보완 ② 상태 추적   → 실패 건을 빠르게 식별
    ├─ 보완 ③ 자동 재시도  → 실패 건 자동 복구
    ├─ 보완 ④ 수동 재시도  → 실패 건 즉시 복구
    └─ 보완 ⑤ 에러 핸들링 → 에러 정보를 이력에 기록 가능하게
