함수형 인터페이스와 람다
==============================================
Java 8+ / 실무 Java 11 지원

==============================================
1. 람다 (Lambda)란
==============================================

익명 함수를 짧게 표현하는 문법.
Stream의 filter, map 등에 넘기는 그 화살표 표현식이 람다.

----------------------------------------------
1-1. 기존 방식 vs 람다
----------------------------------------------

  // 기존: 익명 클래스
  list.stream().filter(new Predicate<MenuDto>() {
      @Override
      public boolean test(MenuDto m) {
          return m.getDepth() == 3;
      }
  });

  // 람다로 축약
  list.stream().filter(m -> m.getDepth() == 3);

----------------------------------------------
1-2. 람다 문법 형태
----------------------------------------------

  // 파라미터 1개, 단일 표현식
  m -> m.getDepth() == 3

  // 파라미터 1개, 블록 (여러 줄)
  m -> {
      System.out.println(m.getMenuName());
      return m.getDepth() == 3;
  }

  // 파라미터 없음
  () -> System.out.println("hello")

  // 파라미터 2개
  (a, b) -> a + b

  // 타입 명시 (생략 가능, 컴파일러가 추론)
  (MenuDto m) -> m.getDepth() == 3

==============================================
2. 함수형 인터페이스
==============================================

추상 메서드가 딱 1개인 인터페이스.
람다를 변수에 담거나 파라미터로 넘길 때 타입으로 사용.

java.util.function 패키지에 표준 제공.

----------------------------------------------
2-1. Predicate<T> - 조건 판단 (boolean 반환)
----------------------------------------------

  Predicate<MenuDto> isDepth3 = m -> m.getDepth() == 3;
  Predicate<MenuDto> isActive = m -> "Y".equals(m.getUseYn());

  // 직접 호출
  boolean result = isDepth3.test(menu);

  // Stream에서 사용
  list.stream().filter(isDepth3).collect(Collectors.toList());

  // Predicate 조합
  Predicate<MenuDto> isDepth3AndActive = isDepth3.and(isActive);
  Predicate<MenuDto> isDepth3OrActive  = isDepth3.or(isActive);
  Predicate<MenuDto> isNotDepth3       = isDepth3.negate();

  list.stream()
      .filter(isDepth3.and(isActive))
      .collect(Collectors.toList());

----------------------------------------------
2-2. Function<T, R> - 변환 (T 입력 → R 반환)
----------------------------------------------

  Function<MenuDto, String> getName = MenuDto::getMenuName;
  Function<MenuDto, Integer> getDepth = MenuDto::getDepth;

  // 직접 호출
  String name = getName.apply(menu);

  // Stream에서 사용
  list.stream().map(getName).collect(Collectors.toList());

  // Function 체이닝 (andThen)
  Function<String, Integer> strLength = String::length;
  Function<MenuDto, Integer> nameLength = getName.andThen(strLength);
  // MenuDto → menuName(String) → 길이(Integer)

----------------------------------------------
2-3. Consumer<T> - 소비 (반환값 없음)
----------------------------------------------

  Consumer<MenuDto> printName = m -> System.out.println(m.getMenuName());

  // 직접 호출
  printName.accept(menu);

  // Stream forEach에서 사용
  list.stream().forEach(printName);

  // Consumer 체이닝 (andThen)
  Consumer<MenuDto> printDepth = m -> System.out.println(m.getDepth());
  Consumer<MenuDto> printBoth = printName.andThen(printDepth);
  list.forEach(printBoth);

----------------------------------------------
2-4. Supplier<T> - 공급 (파라미터 없음 → T 반환)
----------------------------------------------

  Supplier<List<MenuDto>> emptyList = ArrayList::new;

  // 직접 호출
  List<MenuDto> list = emptyList.get();

  // Optional에서 자주 사용
  MenuDto menu = optional.orElseGet(() -> new MenuDto());
  MenuDto menu = optional.orElseGet(MenuDto::new);  // 메서드 참조 축약

----------------------------------------------
2-5. BiFunction<T, U, R> - 파라미터 2개 변환
----------------------------------------------

  BiFunction<String, Integer, String> repeat = (s, n) -> s.repeat(n);
  String result = repeat.apply("ab", 3);  // "ababab"

----------------------------------------------
2-6. 표 요약
----------------------------------------------

  인터페이스           | 추상 메서드       | 용도
  --------------------+------------------+--------------------
  Predicate<T>        | test(T) → bool   | 조건 판단
  Function<T, R>      | apply(T) → R     | 변환
  Consumer<T>         | accept(T) → void | 소비 (출력, 저장 등)
  Supplier<T>         | get() → T        | 생성/공급
  BiFunction<T,U,R>   | apply(T,U) → R   | 파라미터 2개 변환
  UnaryOperator<T>    | apply(T) → T     | 같은 타입 변환
  BinaryOperator<T>   | apply(T,T) → T   | 같은 타입 2개 → 1개

==============================================
3. 메서드 참조 (::)
==============================================

람다를 더 짧게 쓰는 표기법.
메서드를 직접 가리켜서 람다 자리에 넘김.

----------------------------------------------
3-1. 4가지 유형
----------------------------------------------

  유형 1: 정적 메서드 참조
    람다:            n -> Integer.parseInt(n)
    메서드 참조:     Integer::parseInt

  유형 2: 특정 인스턴스의 메서드 참조
    String prefix = "Hello";
    람다:            s -> prefix.concat(s)
    메서드 참조:     prefix::concat

  유형 3: 임의 인스턴스의 메서드 참조 (가장 자주 씀)
    람다:            m -> m.getMenuName()
    메서드 참조:     MenuDto::getMenuName

    람다:            s -> s.length()
    메서드 참조:     String::length

  유형 4: 생성자 참조
    람다:            () -> new ArrayList<>()
    메서드 참조:     ArrayList::new

    람다:            () -> new MenuDto()
    메서드 참조:     MenuDto::new

----------------------------------------------
3-2. 실제 사용 예시
----------------------------------------------

  // 유형 3 - 가장 흔함
  list.stream()
      .map(MenuDto::getMenuName)       // m -> m.getMenuName()
      .collect(Collectors.toList());

  list.stream()
      .sorted(Comparator.comparing(MenuDto::getSortOrder))
      .collect(Collectors.toList());

  list.stream()
      .collect(Collectors.groupingBy(MenuDto::getParentId));

  // 유형 4 - Optional/Stream에서 기본값 생성
  Optional<MenuDto> opt = ...;
  MenuDto menu = opt.orElseGet(MenuDto::new);

  // 유형 1 - 타입 변환
  List<String> strIds = List.of("1", "2", "3");
  List<Integer> ids = strIds.stream()
      .map(Integer::parseInt)
      .collect(Collectors.toList());

----------------------------------------------
3-3. 람다 vs 메서드 참조 선택 기준
----------------------------------------------

  // 람다 본문이 메서드 호출 1개만이면 → 메서드 참조 추천
  m -> m.getMenuName()     →  MenuDto::getMenuName   (더 간결)

  // 람다 본문에 추가 로직이 있으면 → 람다 유지
  m -> m.getDepth() == 3   →  메서드 참조 불가 (조건식 포함)

==============================================
4. 함수형 인터페이스를 파라미터로 받는 메서드
==============================================

내가 직접 메서드를 만들 때 람다를 파라미터로 받을 수 있음.

  // 조건을 외부에서 주입받는 필터 유틸
  public List<MenuDto> filterMenus(List<MenuDto> list,
                                    Predicate<MenuDto> condition) {
      return list.stream()
          .filter(condition)
          .collect(Collectors.toList());
  }

  // 호출 시 람다로 조건 넘김
  List<MenuDto> depth3 = filterMenus(menuList, m -> m.getDepth() == 3);
  List<MenuDto> active = filterMenus(menuList, m -> "Y".equals(m.getUseYn()));

  → 전략 패턴을 람다로 구현하는 방식. 실무에서 유틸 메서드 만들 때 유용.
