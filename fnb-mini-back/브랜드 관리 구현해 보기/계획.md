# 브랜드 관리 구현 계획

## 목표

실무 프로젝트(cjfw-fscps-bo-api)의 브랜드 저장 로직을 분석하고,
**동시성 문제와 트랜잭션 경계 문제**를 해결한 개선된 버전을 fnb-mini-back에 구현한다.

---

## 현재 상태

### fnb-mini-back 프로젝트
- Spring Boot 3.5.10, Java 17, MyBatis 3.0.5, PostgreSQL 15 (Docker)
- 포트: 18080, DB: localhost:15432/fnbmini
- HikariCP: max-pool 5, min-idle 2
- **아직 아무것도 구현 안 됨** (Application 클래스만 존재)

### 실무 프로젝트의 문제점 (분석 완료)
1. **트랜잭션 경계 문제**: `@Transactional` 하나로 DB작업 + 외부API 호출 전부 감싸고 있음
2. **커넥션 점유 시간**: DB작업 ~50ms인데 외부API 때문에 5~60초 점유
3. **커넥션 풀 고갈 위험**: HikariCP 10개에 동시 10요청 → 전체 시스템 마비
4. **에러 핸들링 부재**: 외부API 응답 코드 검증 안 함
5. **동기화 상태 추적 없음**: 실패한 동기화를 식별/재시도 불가
6. **동시성 제어 없음**: 낙관적/비관적 락 없음

---

## 구현 단계

### Phase 1: 기반 인프라 구축

#### 1-1. DB 테이블 생성 (schema.sql)

```sql
-- 브랜드 마스터
CREATE TABLE brand (
    id              BIGSERIAL PRIMARY KEY,
    brand_code      VARCHAR(20)  NOT NULL UNIQUE,
    brand_name      VARCHAR(100) NOT NULL,
    brand_name_en   VARCHAR(100),
    brand_desc      VARCHAR(500),
    use_yn          CHAR(1)      NOT NULL DEFAULT 'Y',

    -- 동기화 상태 추적 (실무에 없었던 핵심 개선)
    sync_status     VARCHAR(20)  NOT NULL DEFAULT 'NONE',   -- NONE/PENDING/SUCCESS/FAILED
    sync_retry_count INT         NOT NULL DEFAULT 0,
    last_sync_at    TIMESTAMP,
    last_sync_error VARCHAR(500),

    -- 낙관적 락 (실무에 없었던 핵심 개선)
    version         INT          NOT NULL DEFAULT 0,

    -- 감사 필드
    reg_id          VARCHAR(50),
    reg_dttm        TIMESTAMP    NOT NULL DEFAULT NOW(),
    upd_id          VARCHAR(50),
    upd_dttm        TIMESTAMP
);

-- 동기화 이력 (실패 추적 & 재시도 근거)
CREATE TABLE brand_sync_history (
    id              BIGSERIAL PRIMARY KEY,
    brand_id        BIGINT       NOT NULL REFERENCES brand(id),
    sync_type       VARCHAR(20)  NOT NULL,  -- REGISTER / UPDATE
    sync_status     VARCHAR(20)  NOT NULL,  -- PENDING / SUCCESS / FAILED
    request_payload TEXT,
    response_payload TEXT,
    error_message   VARCHAR(500),
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW(),
    completed_at    TIMESTAMP
);
```

#### 1-2. 프로젝트 패키지 구조

```
src/main/java/com/cj/fnbmini/
├── FnbMiniApplication.java
├── common/
│   ├── dto/
│   │   └── ApiResponse.java           ← 공통 응답 DTO
│   └── exception/
│       └── BrandException.java        ← 도메인 예외
├── brand/
│   ├── BrandController.java           ← REST 엔드포인트
│   ├── BrandService.java              ← 비즈니스 로직 (트랜잭션 분리의 핵심)
│   ├── BrandSyncService.java          ← 외부 API 동기화 전담
│   ├── BrandMapper.java               ← MyBatis 인터페이스
│   ├── dto/
│   │   ├── BrandSearchDto.java        ← 조회 조건
│   │   ├── BrandSaveReqDto.java       ← 저장 요청 (C/U/D 상태 포함)
│   │   └── BrandSyncResultDto.java    ← 동기화 결과
│   └── entity/
│       ├── Brand.java                 ← 브랜드 엔티티
│       └── BrandSyncHistory.java      ← 동기화 이력 엔티티
└── external/
    └── ShopApiClient.java             ← 외부 API 호출 (Mock)

src/main/resources/
├── mappers/brand/
│   └── BrandMapper.xml
├── schema.sql                         ← 테이블 DDL
└── application.yml
```

---

### Phase 2: 기본 CRUD 구현

#### 2-1. Entity & DTO

| 클래스 | 역할 |
|--------|------|
| `Brand` | DB 테이블 매핑 (version 포함) |
| `BrandSyncHistory` | 동기화 이력 엔티티 |
| `BrandSearchDto` | 검색 조건 (brandCode, brandName, useYn, syncStatus) |
| `BrandSaveReqDto` | 프론트 그리드에서 넘어오는 C/U/D 상태 목록 |
| `ApiResponse<T>` | 공통 응답 래퍼 (success, message, data) |

#### 2-2. Mapper (MyBatis)

```
selectBrandList(BrandSearchDto)      → 목록 조회
selectBrandById(Long id)             → 단건 조회
insertBrand(Brand)                   → 등록
updateBrand(Brand)                   → 수정
updateBrandWithVersion(Brand)        → 낙관적 락 수정 ★
deleteBrand(Long id)                 → 삭제
updateSyncStatus(...)                → 동기화 상태 업데이트
selectFailedSyncBrands()             → 실패 브랜드 조회 (재시도용)
insertSyncHistory(BrandSyncHistory)  → 이력 저장
```

#### 2-3. Controller (REST API)

```
GET    /api/brands              → 목록 조회
GET    /api/brands/{id}         → 단건 조회
POST   /api/brands              → 저장 (C/U/D 배치)
POST   /api/brands/{id}/retry   → 수동 재시도
GET    /api/brands/sync-failed  → 실패 목록 조회
```

---

### Phase 3: 트랜잭션 분리 (핵심 개선)

실무 코드의 가장 큰 문제를 해결하는 핵심 구간.

#### 실무 (문제 있는 구조)
```
@Transactional                          ← 하나의 큰 트랜잭션
public void savePartnerBrands(...) {
    [DB INSERT/UPDATE]                  ← ~50ms (커넥션 필요)
    [외부 API CP204 호출]               ← ~3초  (커넥션 불필요, 점유 중)
    [외부 API CP206 호출]               ← ~3초  (커넥션 불필요, 점유 중)
}                                       ← 총 ~6초 커넥션 점유
```

#### 개선 (트랜잭션 3분할)
```
public void saveBrands(List<BrandSaveReqDto> list) {   ← 오케스트레이터 (트랜잭션 없음)

    // TX#1: DB 저장 + PENDING 마킹 (커밋 후 커넥션 즉시 반환)
    List<Brand> saved = self.saveBrandsToDb(list);      ← ~50ms

    // TX 밖: 외부 API 호출 (커넥션 점유 없음)
    Map<Long, SyncResult> results = brandSyncService.syncToExternalApi(saved);  ← ~6초

    // TX#2: 동기화 결과 반영
    self.updateSyncResults(results);                    ← ~30ms
}

@Transactional
public List<Brand> saveBrandsToDb(List<BrandSaveReqDto> list) {
    // INSERT/UPDATE + sync_status='PENDING' 설정
    // 커밋 → 커넥션 반환
}

@Transactional
public void updateSyncResults(Map<Long, SyncResult> results) {
    // sync_status = SUCCESS/FAILED 업데이트
    // brand_sync_history INSERT
}
```

**self 주입 패턴**: `@Transactional`이 같은 클래스 내 호출에서도 동작하도록
```java
@Autowired
private BrandService self;  // AOP 프록시를 통한 자기 참조
```

---

### Phase 4: 동시성 제어

#### 4-1. 낙관적 락 (Optimistic Locking)

같은 브랜드를 동시에 수정할 때 데이터 손실 방지:

```xml
<update id="updateBrandWithVersion">
    UPDATE brand
    SET brand_name = #{brandName},
        use_yn = #{useYn},
        version = version + 1,
        upd_dttm = NOW()
    WHERE id = #{id}
      AND version = #{version}   ← 버전 불일치 시 0행 업데이트 → 예외 발생
</update>
```

Service에서 0행 업데이트 감지:
```java
int updated = brandMapper.updateBrandWithVersion(brand);
if (updated == 0) {
    throw new BrandException("다른 사용자가 먼저 수정했습니다. 새로고침 후 다시 시도하세요.");
}
```

#### 4-2. 비관적 락 (참고용, 필요 시)

동시 승인 방지 등 특수 케이스:
```xml
<select id="selectBrandForUpdate">
    SELECT * FROM brand WHERE id = #{id} FOR UPDATE
</select>
```

---

### Phase 5: 외부 API Mock & 에러 핸들링

#### 5-1. ShopApiClient (외부 API Mock)

실무의 미들웨어 → Airstar 3-hop 구조를 단순화:

```java
@Component
public class ShopApiClient {

    // 실무: middlewareApiManager.sendRequest(CP204)
    // 여기서는: RestClient로 직접 호출 (또는 Mock)

    public SyncResult registerBrand(Brand brand) {
        // Mock: 랜덤 성공/실패 또는 지연 시뮬레이션
        // 실패 시 SyncResult에 에러 코드/메시지 담아서 반환
    }

    public SyncResult updateBrand(Brand brand) {
        // 위와 동일
    }
}
```

#### 5-2. 보상 트랜잭션

외부 API 성공 → 내부 DB 업데이트 실패 시:
```java
try {
    SyncResult result = shopApiClient.registerBrand(brand);
    self.updateSyncResults(...);  // TX#2
} catch (Exception e) {
    // 보상: 외부 API에 취소 요청
    shopApiClient.cancelBrand(brand);
    log.error("보상 트랜잭션 실행", e);
}
```

---

### Phase 6: 재시도 메커니즘

```java
// 수동 재시도 (API)
@PostMapping("/{id}/retry")
public ApiResponse<Void> retrySync(@PathVariable Long id) {
    brandService.retrySyncForBrand(id);
}

// 자동 재시도 (스케줄러, 선택 구현)
@Scheduled(fixedRate = 300_000)  // 5분마다
public void retryFailedSyncs() {
    List<Brand> failed = brandMapper.selectFailedSyncBrands();  // retry_count < 3
    for (Brand brand : failed) {
        brandSyncService.syncSingleBrand(brand);
    }
}
```

---

## 구현 순서 요약

| 단계 | 내용 | 핵심 포인트 |
|------|------|------------|
| **Phase 1** | DB 테이블 + 패키지 구조 | sync_status, version 컬럼이 핵심 |
| **Phase 2** | 기본 CRUD | 실무 패턴 따르되 심플하게 |
| **Phase 3** | 트랜잭션 분리 | **가장 중요** - self 주입, 3분할 |
| **Phase 4** | 낙관적 락 | version 컬럼 + WHERE 조건 |
| **Phase 5** | 외부 API Mock + 보상 | 실패 시나리오 시뮬레이션 |
| **Phase 6** | 재시도 메커니즘 | 수동 API + 자동 스케줄러 |

---

## 실무 대비표 (완성 후 비교 가능)

| 항목 | 실무 (문제) | fnb-mini (개선) |
|------|------------|----------------|
| 트랜잭션 범위 | 1개 (전체) | 3개 (DB저장/API호출/결과반영) |
| 커넥션 점유 | 5~60초 | ~50ms |
| 에러 핸들링 | 로그만 출력 | try-catch + 상태 저장 |
| 동기화 추적 | 없음 | sync_status + history 테이블 |
| 재시도 | 없음 | 수동 API + 자동 스케줄러 |
| 낙관적 락 | 없음 | version 컬럼 |
| 비관적 락 | 없음 | FOR UPDATE (필요 시) |
| DI 방식 | @Autowired 필드 | @RequiredArgsConstructor 생성자 |
| HTTP 클라이언트 | RestTemplate (레거시) | RestClient (Spring 6+) |
| 외부 API 경로 | 3-hop (BO→미들웨어→Airstar) | 2-hop (Service→shop-api) |

---

## 참고 문서 위치

| 문서 | 경로 |
|------|------|
| 동시성 5가지 패턴 정리 | `C:\dev-challenge-container\docs-for-동시성 문제\docs-for-외부api요청에 대한 동시성 문제\` |
| 실무 브랜드 로직 문제 분석 | `C:\dev-challenge-container\docs-for-동시성 문제\실무 프로젝트의 브랜드 저장 로직의 문제점 분석\` |
| 실무 브랜드 로직 정리 | `C:\dev-challenge-container\docs-for-동시성 문제\실무-브랜드 저장 관련 로직 정리\` |
| 현업 CRUD 프로세스 분석 | `C:\dev-challenge-container\docs-for-동시성 문제\docs-for-현업 프로젝트 분석\` |
| 실무 백엔드 소스 | `C:\cj-fnb-container\cjfw-fscps-bo-api\src\main\java\com\cj\freshway\fs\cps\airstar\brand\` |
