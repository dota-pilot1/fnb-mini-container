================================================================
정산 시스템 동시성 문제 해결 — 연습 프로젝트 구현 계획
================================================================

■ 목표

  브랜드 관리에서 이미 구현한 3가지 조치:
    1. 트랜잭션 분리
    2. 낙관적 락
    3. 이력 테이블

  정산 시스템에서 추가로 필요한 조치들을 구현:
    4. 비관적 락 (SELECT FOR UPDATE)
    5. 멱등성 키 (중복 처리 방지)
    6. 보상 트랜잭션 (외부 API 성공 → DB 실패 시 취소)

  실무의 PosSalesRegService를 간소화한 "일매출 정산" 기능.


■ 실무 vs 미니 매핑

  ┌─────────────────────┬──────────────────────────┐
  │ 실무                 │ 미니                      │
  ├─────────────────────┼──────────────────────────┤
  │ POS 트랜잭션 데이터  │ daily_sales (일매출)      │
  │ 일매출 정산          │ settlement (정산 확정)    │
  │ SAP 전표 전송        │ fnb-external-api 호출    │
  │ FS매출 데이터(TFMCL) │ settlement_ledger (원장)  │
  │ 매장(shop)           │ shop (매장)              │
  └─────────────────────┴──────────────────────────┘


================================================================
DB 설계 (schema.sql 추가)
================================================================

■ shop (매장 마스터)

  CREATE TABLE IF NOT EXISTS shop (
    id          BIGSERIAL PRIMARY KEY,
    shop_code   VARCHAR(20)  NOT NULL UNIQUE,
    shop_name   VARCHAR(100) NOT NULL,
    use_yn      VARCHAR(1)   DEFAULT 'Y'
  );

■ daily_sales (일매출 — POS에서 올라온 원본 데이터)

  CREATE TABLE IF NOT EXISTS daily_sales (
    id          BIGSERIAL PRIMARY KEY,
    shop_id     BIGINT       NOT NULL,
    sales_date  DATE         NOT NULL,
    cash_amt    BIGINT       DEFAULT 0,    -- 현금
    card_amt    BIGINT       DEFAULT 0,    -- 카드
    easy_amt    BIGINT       DEFAULT 0,    -- 간편결제
    total_amt   BIGINT       DEFAULT 0,    -- 합계
    created_at  TIMESTAMP    DEFAULT NOW(),
    UNIQUE(shop_id, sales_date)
  );

■ settlement (정산 확정 — 실무의 SA_CLOSE_DAILY_SALES_M)

  CREATE TABLE IF NOT EXISTS settlement (
    id               BIGSERIAL PRIMARY KEY,
    shop_id          BIGINT      NOT NULL,
    sales_date       DATE        NOT NULL,
    total_amt        BIGINT      DEFAULT 0,
    status           VARCHAR(20) DEFAULT 'READY',
                     -- READY → PROCESSING → SETTLED → FAILED
    version          INT         DEFAULT 0,
    idempotency_key  VARCHAR(64) UNIQUE,
    sap_sync_status  VARCHAR(20) DEFAULT 'NONE',
                     -- NONE → PENDING → SUCCESS → FAILED
    sap_sync_error   VARCHAR(500),
    settled_at       TIMESTAMP,
    settled_by       VARCHAR(50),
    created_at       TIMESTAMP   DEFAULT NOW(),
    UNIQUE(shop_id, sales_date)
  );

■ settlement_ledger (정산 원장 — 실무의 TFMCL006)

  CREATE TABLE IF NOT EXISTS settlement_ledger (
    id              BIGSERIAL PRIMARY KEY,
    settlement_id   BIGINT      NOT NULL,
    shop_id         BIGINT      NOT NULL,
    sales_date      DATE        NOT NULL,
    ledger_type     VARCHAR(10) NOT NULL,  -- NORMAL / REVERSE (역분개)
    cash_amt        BIGINT      DEFAULT 0,
    card_amt        BIGINT      DEFAULT 0,
    easy_amt        BIGINT      DEFAULT 0,
    total_amt       BIGINT      DEFAULT 0,
    del_yn          VARCHAR(1)  DEFAULT 'N',
    created_at      TIMESTAMP   DEFAULT NOW()
  );

■ settlement_sync_history (정산 동기화 이력)

  CREATE TABLE IF NOT EXISTS settlement_sync_history (
    id                BIGSERIAL PRIMARY KEY,
    settlement_id     BIGINT      NOT NULL,
    sync_type         VARCHAR(20),  -- SETTLE / REVERSE
    sync_status       VARCHAR(20),  -- SUCCESS / FAILED
    request_payload   TEXT,
    response_payload  TEXT,
    error_message     VARCHAR(500),
    created_at        TIMESTAMP   DEFAULT NOW()
  );


================================================================
백엔드 구현
================================================================

■ 패키지 구조

  com.cj.fnbmini.settlement/
  ├── SettlementController.java
  ├── SettlementService.java       ← 핵심 (동시성 조치 집중)
  ├── SettlementSyncService.java   ← 외부 API 호출 (TX 없음)
  ├── SettlementMapper.java
  ├── dto/
  │   ├── SettlementReqDto.java
  │   ├── SettlementSearchDto.java
  │   └── SettlementSyncResultDto.java
  └── entity/
      ├── DailySales.java
      ├── Settlement.java
      ├── SettlementLedger.java
      └── SettlementSyncHistory.java

  resources/mappers/settlement/
  └── SettlementMapper.xml


■ API 엔드포인트

  GET  /api/settlements              매장별 정산 목록 조회
  GET  /api/settlements/daily-sales  일매출 데이터 조회
  POST /api/settlements/settle       정산 실행 (핵심!)
  POST /api/settlements/{id}/retry   정산 SAP 재시도


■ 정산 실행 핵심 흐름 (settle)

  SettlementService.settle(shopId, salesDate, idempotencyKey)

  0단계: 멱등성 체크
    → idempotency_key로 조회
    → 이미 있으면 기존 결과 반환 (중복 방지)

  1차 TX: 비관적 락 + 정산 데이터 생성
    → SELECT ... FOR UPDATE (daily_sales 행 잠금)
    → settlement INSERT (status=PROCESSING)
    → 기존 원장 역분개 (REVERSE 원장 INSERT)
    → 새 원장 생성 (NORMAL 원장 INSERT)
    → 커밋 → 커넥션 반환

  2차 NO TX: 외부 API(SAP) 호출
    → 역분개 전표 전송 + 신규 전표 전송
    → 커넥션 점유 없음

  3차 TX: 결과 반영
    → settlement.status = SETTLED 또는 FAILED
    → sap_sync_status 업데이트
    → settlement_sync_history 이력 저장
    → 커밋 → 커넥션 반환

  보상: 2차에서 일부 성공 + 일부 실패 시
    → 성공한 건에 대해 취소 API 호출
    → settlement.status = FAILED + 에러 기록


================================================================
추가 동시성 조치 상세
================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

조치 4. 비관적 락 (SELECT FOR UPDATE)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  브랜드 관리: 낙관적 락 (version)
  → 충돌 시 "새로고침 후 다시 시도" (사용자 재시도)

  정산: 비관적 락 (FOR UPDATE)
  → 정산 시작 시 해당 행을 잠금 → 다른 TX는 대기
  → 금전 데이터라 "일단 막고 순서대로 처리"가 맞음

  SQL:
  <select id="selectDailySalesForUpdate">
    SELECT * FROM daily_sales
    WHERE shop_id = #{shopId}
      AND sales_date = #{salesDate}
    FOR UPDATE
  </select>

  → 같은 매장/날짜를 동시에 정산하려는 요청이 직렬화됨


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

조치 5. 멱등성 키 (Idempotency Key)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  프론트에서 정산 요청 시 UUID를 생성해서 함께 전송.
  서버는 이 키로 중복 여부를 판단.

  요청: POST /api/settlements/settle
  {
    "shopId": 1,
    "salesDate": "2024-01-15",
    "idempotencyKey": "550e8400-e29b-41d4-a716-446655440000"
  }

  서버 로직:
  Settlement existing = mapper.selectByIdempotencyKey(key);
  if (existing != null) {
      return existing;  // 이미 처리됨 → 기존 결과 반환
  }

  왜 필요:
  → 네트워크 타임아웃으로 프론트가 재요청할 때
  → 같은 정산이 2번 실행되면 이중 전표 → 회계 꼬임


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

조치 6. 보상 트랜잭션 (Compensating Transaction)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  외부 API(SAP)에 역분개 + 신규 전표를 보내는데:
  → 역분개 성공 + 신규 전표 실패 시?
  → SAP에는 역분개만 반영 → 데이터 불일치

  해결: 역분개 성공한 걸 취소하는 "보상 API" 호출

  코드:
  // 2차: 외부 API 호출
  reverseResult = syncService.sendReverse(settlement);  // 성공
  normalResult = syncService.sendNormal(settlement);     // 실패!

  if (reverseResult.isSuccess() && !normalResult.isSuccess()) {
      // 보상: 역분개 취소 요청
      syncService.cancelReverse(settlement);
  }

  브랜드 관리에서는 불필요했던 이유:
  → 브랜드 동기화 실패 = 나중에 재시도하면 그만
  → 정산은 부분 성공이 허용 안 됨 (전표가 꼬임)


================================================================
프론트엔드 구현
================================================================

■ 신규 파일

  pages/settlement/SettlementPage.jsx        정산 메인 페이지
  components/settlement/SettlementSearch.jsx  검색폼 (매장, 날짜)
  components/settlement/DailySalesGrid.jsx   일매출 그리드
  components/settlement/SettlementGrid.jsx   정산 내역 그리드
  api/settlement/settlement-fetch.js         API 호출 함수

■ 수정 파일

  App.jsx         → /settlement 라우트 추가
  Header.jsx      → menus에 { path: '/settlement', name: '매출 정산' } 추가

■ 화면 구성

  ┌─────────────────────────────────────────┐
  │ 검색: [매장 선택] [날짜 선택] [조회]     │
  ├──────────────────┬──────────────────────┤
  │ 일매출 데이터     │ 정산 내역            │
  │ (daily_sales)    │ (settlement)         │
  │                  │                      │
  │ 현금: 150,000    │ 상태: SETTLED        │
  │ 카드: 350,000    │ SAP: SUCCESS         │
  │ 간편: 100,000    │ 정산일: 2024-01-15   │
  │ 합계: 600,000    │                      │
  │                  │ [정산 실행]  [재시도] │
  └──────────────────┴──────────────────────┘

■ 멱등성 키 생성 (프론트)

  정산 실행 버튼 클릭 시:
  const idempotencyKey = crypto.randomUUID()
  fetchSettle({ shopId, salesDate, idempotencyKey })


================================================================
fnb-external-api (NestJS) 추가
================================================================

  기존 /api/brands/* 에 추가:

  POST /api/settlements/reverse    역분개 전표 전송
  POST /api/settlements/normal     신규 전표 전송
  POST /api/settlements/cancel     보상 취소 요청

  → 지연 시뮬레이션 (2~4초)
  → 랜덤 실패 시뮬레이션 (10% 확률)


================================================================
구현 순서
================================================================

  1단계: DB + 기본 CRUD
    - schema.sql 테이블 추가 (shop, daily_sales, settlement 등)
    - 초기 데이터 INSERT (매장 3개, 일매출 샘플)
    - 백엔드 Entity, Mapper, 조회 API

  2단계: 정산 핵심 로직 (백엔드)
    - SettlementService.settle() 트랜잭션 3분할
    - 비관적 락 (SELECT FOR UPDATE)
    - 멱등성 키 체크
    - 원장 역분개 + 신규 생성

  3단계: 외부 API 연동
    - fnb-external-api에 정산 엔드포인트 추가
    - SettlementSyncService (TX 없음)
    - 보상 트랜잭션 로직
    - 이력 테이블 저장

  4단계: 프론트엔드
    - 헤더 메뉴 추가
    - 정산 페이지 (검색 + 그리드 2개)
    - 멱등성 키 생성 + 전송
    - 정산 실행 / 재시도 버튼

  5단계: 테스트 + 문서
    - 동시 요청 테스트 (비관적 락 검증)
    - 중복 요청 테스트 (멱등성 검증)
    - 부분 실패 테스트 (보상 트랜잭션 검증)


================================================================
브랜드 관리 vs 정산 — 조치 비교 (최종)
================================================================

  ┌──────────────────────┬────────────┬────────────┐
  │ 조치                  │ 브랜드 관리 │ 정산       │
  ├──────────────────────┼────────────┼────────────┤
  │ 1. 트랜잭션 분리      │ ✅          │ ✅ (동일)  │
  │ 2. 낙관적 락         │ ✅          │ ✅ (유지)  │
  │ 3. 이력 테이블        │ ✅          │ ✅ (동일)  │
  │ 4. 비관적 락         │ ❌ 불필요   │ ✅ 신규    │
  │ 5. 멱등성 키         │ ❌ 불필요   │ ✅ 신규    │
  │ 6. 보상 트랜잭션     │ ❌ 불필요   │ ✅ 신규    │
  │ self-proxy           │ ✅          │ ✅ (동일)  │
  │ 상태 추적            │ ✅          │ ✅ (동일)  │
  │ 자동/수동 재시도      │ ✅          │ ✅ (동일)  │
  │ 에러 핸들링          │ ✅          │ ✅ (동일)  │
  └──────────────────────┴────────────┴────────────┘
