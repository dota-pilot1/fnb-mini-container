메뉴 출력 흐름
==============================================

전체 흐름 요약:
  앱 시작 → API 호출 → 트리 조립 → MenuContext 저장 → 헤더/사이드바 렌더링

==============================================
1. 백엔드: flat 리스트 → 트리 구조 조립
==============================================

  1-1. DB 조회 (menuMapper.xml)
       SELECT id, parent_id, depth, menu_name, component_name, sort_order, use_yn
       FROM menu
       WHERE use_yn = 'Y'
       ORDER BY depth, sort_order, id

       → flat 리스트로 조회 (DB는 계층 모름)

  1-2. 트리 조립 (MenuService.java)
       flat 리스트를 받아서 parent_id 기준으로 트리 구조로 만듦

       핵심 로직:
         depth 3 목록 필터링
         → 각 depth 3의 subMenus에 depth 4 붙이기
         → 각 depth 4의 subMenus에 depth 5 붙이기 (재귀)

  1-3. API 응답 (MenuController.java)
       GET /api/menu/tree
       → 트리 구조 JSON 응답

       응답 예시:
       [
         {
           "id": 1, "depth": 3, "menuName": "기준 정보 관리",
           "subMenus": [
             {
               "id": 10, "depth": 4, "menuName": "브랜드",
               "subMenus": [
                 { "id": 100, "depth": 5, "menuName": "브랜드 관리",
                   "componentName": "BrandPage" }
               ]
             }
           ]
         },
         ...
       ]

==============================================
2. 프론트: MenuContext에서 상태 관리
==============================================

  파일: src/context/MenuContext.jsx

  앱 초기화 시 (useEffect []):
    fetchMenuTree() 호출
    → 응답 배열 = headerMenus (depth 3 목록)
    → 첫 번째 헤더 메뉴를 기본 활성화
    → 첫 번째 헤더의 subMenus = leftMenus (사이드바 초기값)

  상태 3가지:
    headerMenus    → Header.jsx에서 사용 (헤더 탭 렌더링)
    leftMenus      → LeftMenu.jsx에서 사용 (사이드바 렌더링)
    activeHeaderId → 현재 활성화된 헤더 id (active 스타일용)

  상태 변경 2가지:
    handleHeaderClick(menu)
      헤더 클릭 시 호출
      → activeHeaderId 갱신
      → leftMenus = 클릭한 헤더의 subMenus로 교체

    syncLeftMenuByHeaderId(headerMenuId)
      탭 전환 시 호출 (TabContext 콜백으로 연결)
      → 해당 headerMenuId를 가진 헤더를 headerMenus에서 찾음
      → leftMenus 갱신 (탭 소속 헤더에 맞게 사이드바 동기화)

==============================================
3. 프론트: 화면 렌더링
==============================================

  헤더 (Header.jsx)
    useMenu()의 headerMenus 순회
    → depth 3 메뉴를 button으로 렌더링
    → 클릭 시 handleHeaderClick(menu) 호출
    → activeHeaderId와 일치하면 active 스타일 적용

  사이드바 (LeftMenu.jsx)
    useMenu()의 leftMenus 순회 (depth 4 배열)

    depth 4 렌더링:
      → 카테고리 헤더 button (아코디언 토글)
      → 기본값 펼침 (openCategories[id] !== false)

    depth 5 렌더링 (카테고리 하위):
      → 실제 메뉴 button
      → 클릭 시 addTab(item, activeHeaderId) 호출
      → 현재 활성 탭 menuId와 일치하면 active 스타일

  탭 등록 및 화면 전환 흐름:
    depth 5 클릭
      → addTab(item, activeHeaderId)
         tabs 배열에 { menuId, menuName, componentName, headerMenuId } 추가
         activeTabId 갱신
      → Layout.jsx에서 activeTab.componentName 읽음
      → componentRegistry[componentName] = lazy import된 컴포넌트
      → Suspense로 렌더링

==============================================
4. 탭 전환 시 사이드바 동기화
==============================================

  문제:
    탭 A (기준 정보 관리 소속) 열린 상태에서
    헤더 "정산 관리" 클릭 → 사이드바 갱신됨
    탭 A 다시 클릭 → 사이드바가 "정산 관리" 그대로 (버그)

  해결 구조:
    addTab()  → tab에 headerMenuId 저장
    changeTab() → onTabChangeCb(tab.headerMenuId) 호출
    Layout.jsx → registerTabChangeCallback(syncLeftMenuByHeaderId) 등록
    syncLeftMenuByHeaderId() → 해당 헤더로 사이드바 자동 갱신

  콜백 등록 흐름:
    Layout.jsx의 useEffect에서
      registerTabChangeCallback(syncLeftMenuByHeaderId) 실행
      → TabContext의 onTabChangeCb에 MenuContext 함수 주입
      → 탭 전환 시 자동으로 사이드바 동기화

==============================================
5. componentRegistry 연결
==============================================

  파일: src/componentRegistry.js

  DB의 component_name 값 → 실제 컴포넌트 lazy import 매핑

  const componentRegistry = {
    BrandPage:       lazy(() => import('@/pages/brand/BrandPage')),
    SyncHistoryPage: lazy(() => import('@/pages/sync-history/SyncHistoryPage')),
    SettlementPage:  lazy(() => import('@/pages/settlement/SettlementPage')),
    MenuMngPage:     lazy(() => import('@/pages/menu/MenuMngPage')),
  }

  새 메뉴 추가 시 작업:
    1. DB에 depth 5 레코드 insert (component_name 지정)
    2. 실제 컴포넌트 파일 생성
    3. componentRegistry.js에 키 → import 추가
    → 끝. 라우터 수정 불필요
