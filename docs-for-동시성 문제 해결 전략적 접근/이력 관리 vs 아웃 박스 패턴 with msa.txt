============================================================
DB 저장 + 외부 API 호출의 동시성 문제 — 전략적 접근 FAQ
============================================================


Q1. 전략이 크게 몇 가지야?
============================================================

두 가지다.

■ 1차 방식 — 이력 관리 (트랜잭션 분리 + 실패 후처리)

  문제가 일어날 지점을 미리 예상하고,
  외부 API 호출을 트랜잭션 밖으로 분리한 뒤,
  실패 이력을 테이블로 관리 → 실패 건에 대해 재시도.

  흐름:
    [1차 TX: DB 저장] → [API 호출] → [2차 TX: 결과 + 이력 저장]

  한계:
    DB 저장 성공 후 서버가 아예 죽으면 (프로세스 크래시, OOM 등)
    → 이력 테이블에 아무 기록도 안 남음
    → "API를 호출해야 한다"는 사실 자체가 유실됨

■ 2차 방식 — 아웃박스 패턴 (호출 예약을 같은 TX에 기록)

  네트워크 장애·서버 크래시 자체도 미리 예상하고,
  외부 API를 바로 호출하지 않는다.
  "요청을 날릴 거라는 예약"만 업무 데이터와 같은 TX에 저장.
  실제 호출은 별도 워커(스케줄러)가 나중에 처리.

  흐름:
    [TX: DB 저장 + outbox에 "호출 예약" 기록] → 즉시 응답
    [워커: outbox 읽기 → API 호출 → 결과 업데이트]


Q2. 어떤 방식이 더 적절해?
============================================================

대부분은 1차 방식으로 충분하다.

■ 1차 방식으로 커버 안 되는 케이스:
  - 서버가 아예 죽는 경우 (프로세스 크래시, OOM 등)
  - 실무에서 극히 드문 상황

■ 아웃박스가 필수인 경우:
  - MSA에서 서비스 간 이벤트 전달 (Kafka 등과 결합)
  - 하루에 수십만 건 이상 처리하는 대규모 트래픽
  - 금융권처럼 "한 건도 유실 불가" 수준의 요구사항

■ 실무 현실:
  - 대부분의 모놀리식 서비스 → 1차 방식으로 충분
  - 서버 죽어서 유실되는 건 → 운영 모니터링 + 수동 보정으로 처리
  - 아웃박스 도입하면 → 워커, 데드레터, 중복 처리 등 복잡도 크게 증가

  정리:
    1차 방식: "문제가 생기면 기록하고 재시도한다" (90% 실무에서 충분)
    아웃박스: "문제가 생길 여지 자체를 없앤다" (MSA/대규모에서 필요)


Q3. 두 방식이 사실상 비슷한 거 아냐?
============================================================

맞다. 코드 구성 요소는 거의 동일하다.

  ┌──────────────────────────┬──────────────┬──────────────┐
  │ 구성 요소                │ 이력 관리     │ 아웃박스      │
  ├──────────────────────────┼──────────────┼──────────────┤
  │ 멱등성 키                │ 필요          │ 필요          │
  │ 재시도 스케줄러           │ 필요          │ 필요 (= 워커) │
  │ 상태 관리 (PENDING 등)   │ 필요          │ 필요          │
  │ 데드레터 처리             │ 필요          │ 필요          │
  │ 이력 테이블              │ sync_history  │ outbox        │
  └──────────────────────────┴──────────────┴──────────────┘

코드상 달라지는 건 딱 두 군데:

  1. 서비스 메서드
     - 이력 관리: TX 커밋 후 바로 API 호출
     - 아웃박스: API 호출 안 하고 끝남 (outbox 기록만)

  2. 워커의 역할
     - 이력 관리: FAILED 건만 재시도 (보조 역할)
     - 아웃박스: PENDING 건 전부 처리 (최초 호출도 워커가 함)

이력 관리에 재시도까지 갖추면,
아웃박스로 전환하는 건 "API 호출 위치를 서비스에서 워커로 옮기는"
정도의 리팩토링이다.


Q4. 그러면 실질적 차이가 뭔데?
============================================================

개발·테스트 과정에서 차이가 크다.

■ 이력 관리:
  - 서비스 메서드 안에서 바로 API 호출 → 즉시 성공/실패 확인 가능
  - 워커 없어도 정상 흐름은 돌아감
  - 개발 순서: 서비스 로직 완성 → 정상 동작 확인 → 나중에 스케줄러 추가

■ 아웃박스:
  - 서비스는 DB 기록만 하고 끝 → 워커 없으면 API가 아예 안 나감
  - 워커가 핵심 경로(critical path)에 있음
  - 개발 순서: 서비스 + 워커 둘 다 완성해야 정상 동작 확인 가능

  ┌──────────────┬─────────────────┬───────────────────────┐
  │              │ 이력 관리        │ 아웃박스               │
  ├──────────────┼─────────────────┼───────────────────────┤
  │ 워커 없이    │ 정상 동작함      │ 동작 안 함             │
  │ 워커의 역할  │ 보조 (재시도)    │ 핵심 (모든 API 호출)   │
  └──────────────┴─────────────────┴───────────────────────┘

모놀리식 + 연습용에서는 이력 관리 방식이 개발 생산성도 좋고 디버깅도 쉽다.


Q5. 용어 정리 — 워커? 데드레터?
============================================================

■ 워커(Worker):
  outbox 테이블을 주기적으로 읽어서 외부 API를 호출하는 별도 프로세스.
  우리 프로젝트의 @Scheduled 스케줄러랑 비슷한데,
  아웃박스에서는 이게 "유일한" 외부 API 호출 경로라는 점이 다르다.

■ 데드레터(Dead Letter):
  재시도를 5번, 10번 해도 계속 실패하는 건.
  "더 이상 자동으로 처리 못 함 → 사람이 봐야 함" 상태로 빼놓는 것.
  이메일/슬랙 알림 보내서 운영자가 수동 확인.


Q6. MSA에서는 왜 Kafka까지 필요해?
============================================================

핵심 이유: 서버를 수평 확장(스케일아웃)하면 스케줄러도 중복 실행된다.

  모놀리식 (우리):
    Spring 서버 1대  →  스케줄러 1개  →  외부 API
    (문제없음)

  MSA (실무):
    Spring 서버 (인스턴스 1)  →  스케줄러 돌림  →  외부 API
    Spring 서버 (인스턴스 2)  →  스케줄러 돌림  →  외부 API  ← 같은 건 2번 호출!
    Spring 서버 (인스턴스 3)  →  스케줄러 돌림  →  외부 API  ← 3번 호출!

같은 코드가 3대에서 돌아가면 스케줄러도 3개.
outbox의 같은 PENDING 건을 3대가 동시에 읽고 3번 호출하는 문제 발생.

해결: Kafka 같은 메시지 큐를 사이에 둔다.

  - outbox → Kafka 발행은 Debezium(CDC)이 담당 (DB 변경 감지라 중복 없음)
  - Kafka 컨슈머가 파티션 단위로 1대에만 메시지 할당
  - 1건의 메시지 = 1대의 컨슈머만 처리 → 중복 없음

즉, 메시지 큐가 "이건 이미 누가 가져갔으니까 너는 다음 거 처리해"를
보장해주는 것이다.

  ┌──────────┬──────────────────┬─────────────────────────┐
  │          │ 서버 1대 (우리)   │ 서버 N대 (MSA)          │
  ├──────────┼──────────────────┼─────────────────────────┤
  │ 스케줄러 │ 1개 → 문제없음    │ N개 → 중복 호출 위험     │
  │ 해결책   │ 필요없음          │ Kafka로 1건=1처리 보장   │
  └──────────┴──────────────────┴─────────────────────────┘


Q7. 결국 Kafka도 별거 아닌 거 아냐?
============================================================

맞다. 본질은 단순하다.

  이력 테이블: DB에 "이거 처리해야 함" 기록 → 스케줄러가 읽고 처리
  Kafka:      큐에 "이거 처리해야 함" 기록 → 컨슈머가 읽고 처리

저장소만 DB → 메시지 큐로 바뀐 거다. 패턴 자체는 똑같다.

다만 관리 포인트가 늘어난다:
  - Kafka 클러스터 운영 (브로커, 주키퍼/크래프트)
  - Debezium(CDC) 설정·모니터링
  - 토픽 파티션 관리
  - 컨슈머 그룹 오프셋 관리
  - 장애 시 메시지 유실/중복 대응

그래서 실무에서도 "트래픽이 진짜 많아서 수평 확장이 필수인가?"를
먼저 따지고, 아니면 그냥 DB 스케줄러로 간다.
Kafka 도입은 기술적 판단보다 운영 비용 대비 이득이 있을 때 하는 거다.


Q8. 한 줄 요약
============================================================

이력 관리든 아웃박스든 Kafka든,
"처리해야 할 일을 기록하고, 별도로 처리하고, 실패하면 재시도한다"
이 본질은 전부 똑같다.

차이는 "어디에 기록하느냐"와 "서버 몇 대에서 돌리느냐"뿐이다.
